<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>dbgen.core.model.run API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dbgen.core.model.run</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import TYPE_CHECKING, List as L

from tqdm import tqdm
import re
from bdb import BdbQuit
import logging
from pathlib import Path

# Internal imports
from dbgen.core.misc import ConnectInfo as ConnI, Test, onlyTest, xTest
from dbgen.core.gen import Gen
from dbgen.core.schema import PathEQ

from dbgen.utils.sql import sqlexecute, sqlselect, Error
from dbgen.utils.str_utils import levenshteinDistance
from dbgen.utils.lists import concat_map
from dbgen.utils.log import setup_logger, default_log_path

# Internal
if TYPE_CHECKING:
    from dbgen.core.model.model import Model

    Model

########################################################


def run(
    self: &#34;Model&#34;,
    conn: ConnI,
    meta_conn: ConnI,
    nuke: str = &#34;&#34;,
    add: bool = False,
    retry: bool = False,
    only: str = &#34;&#34;,
    xclude: str = &#34;&#34;,
    start: str = &#34;&#34;,
    until: str = &#34;&#34;,
    serial: bool = False,
    bar: bool = True,
    clean: bool = False,
    skip_row_count: bool = False,
    batch: int = None,
    write_logs: bool = False,
    log_level: int = logging.INFO,
    log_path: str = None,
) -&gt; None:
    &#34;&#34;&#34;
    This method is point of the model: to run and generate a database according
    to the model&#39;s specified rules.

    - conn/meta_conn: information to connect to database and logging database
    - nuke: By default, this is not used. If &#34;True&#34;/&#34;T&#34;, everything except generators
            tagged &#34;no_nuke&#34; are purged. Otherwise, give a space separated list
            of generator names/tags. If a generator is purged, then any
            tables it populates will be truncated. Any columns it populates will be set all
            to NULL. Any generators with inputs OR outputs that have any overlap with the outputs
            of a purged generator will be purged themselves.
    - add: needed if new entities/columns have been added to the model (but not yet in DB)
    - retry: ignore repeat checking
    - only: only run generators with these names (or these tags)
    - xclude: do not run generators with these names (or these tags)
    - start: start at the generator with this name
    - until: stop at the generator with this name
    - serial: force all Generators to be run without parallelization
    - bar: show progress bars
    - skip_row_count: Skip the select count(1) for all gens (good for large queries)
    - clean: &#39;cleans up&#39; implementation detail columns (deleted) for
    presentation of the resulting database to others...at the cost of not being
    able to call model.run() without nuking again (unless an &#39;unclean&#39; method is
    written, which is in principle possible)

    &#34;&#34;&#34;

    # Run tests on pyblocks
    # ----------------------
    self.test_funcs()

    # # Setup logger and config
    # # --------------------
    path_to_log = log_path or default_log_path
    setup_logger(&#34;dbgen&#34;, log_level, write_logs=write_logs, log_path=Path(path_to_log))
    run_logger = logging.getLogger(&#34;dbgen.run&#34;)

    # Print to-do list for the model
    # ---------------------------------------
    todo = self._todo()
    if todo:
        run_logger.warning(
            &#34;WARNING: the following attributes do not have any generator &#34;
            &#34;to populate them: \n\t-&#34; + &#34;\n\t-&#34;.join(sorted(todo))
        )

    # Validate input
    # ----------------
    assert conn != meta_conn, &#34;Main DB cannot be in same schema as logging DB&#34;
    startErr = &#39;Starting generator (&#34;start&#34;) must be a Generator name&#39;
    assert not start or start in self.gens, startErr
    xclude_ = set(xclude.split())
    only_ = set(only.split())
    for w in only_ | xclude_:
        self._validate_name(w)

    # # Make sure no existing cxns to database
    # # ---------------------------------------
    # conn.kill()
    # meta_conn.kill()

    # Make metatables
    # ----------------
    run_id = self._make_metatables(
        mconn=meta_conn,
        conn=conn,
        nuke=nuke,
        retry=retry,
        only=&#34; &#34;.join(sorted(only_)),
        xclude=&#34; &#34;.join(sorted(xclude_)),
        start=start,
        until=until,
        bar=bar,
    )

    # Clean up database
    # -----------------
    if nuke:
        if nuke.lower() in [&#34;t&#34;, &#34;true&#34;]:
            self.make_schema(conn=conn, nuke=nuke, bar=bar)  # FULL NUKE
        else:
            raise NotImplementedError(&#34;Selective nuking is not working yet&#34;)
            deltags = set(nuke.split())
            delgens = set()
            for gen in self.ordered_gens():
                if set([gen.name] + gen.tags).intersection(deltags):
                    delgens.add(gen.name)
            for gen in self.ordered_gens():
                if gen.name in delgens:
                    gen.purge(conn.connect(), meta_conn.connect())
    elif add:
        msg = &#34;&#34;&#34;
#######################################################################
!!!WARNING!!!!
Add is an extremely experimental feature. Existing rows in
modified tables are not deleted. If you added ID info to a table then
you need to manually truncate that table (and cascade to linked tables)
or else those tables will contain rows with missing ID info in their PKs.

Add should really only be used to add attributes to existing tables
or add new empty tables. Adding identifying FKs from existing tables to new tables
is very dangerous and manual truncation will be necessary.

I hope you know what you are doing!!!
!!!WARNING!!!!
#######################################################################
        &#34;&#34;&#34;
        run_logger.warning(msg)
        for ta in tqdm(self.objs.values(), desc=&#34;Adding new tables&#34;, leave=False):
            for sqlexpr in ta.create():
                try:
                    sqlexecute(conn.connect(), sqlexpr)
                except Error as e:
                    # Error code for duplicate table
                    if e.pgcode == &#34;42701&#34;:
                        run_logger.debug(&#34;dup&#34;)
                        pass
                    # Error code for when a relation doesn&#39;t exist on a table we
                    # are adding
                    elif re.match(
                        &#39;column &#34;\w+&#34; of relation &#34;\w+&#34; does not exist&#39;, str(e)
                    ):
                        run_logger.debug(f&#34;PGERROR: {e}&#34;)
                        pass
                    else:
                        raise Error(e)
        for v in tqdm(self.viewlist, desc=&#34;Adding new views&#34;, leave=False):
            try:
                sqlexecute(conn.connect(), v.create())
            except Error as e:
                # Error code for duplicate table
                if &#34;already exists&#34; in str(e):
                    run_logger.debug(&#34;dup&#34;)
                    pass
                else:
                    raise Error(e)

        for ta in tqdm(self.objs.values(), desc=&#34;Adding new columns&#34;, leave=False):
            for sqlexpr in self.add_cols(ta):
                try:
                    sqlexecute(conn.connect(), sqlexpr)
                except Error as e:
                    # Error code for duplicate column
                    if e.pgcode == &#34;42701&#34;:
                        pass
                    else:
                        raise Error(e)

    # Make &#39;global&#39; database connections (active throughout whole process)
    # ----------------------------------------------------------------------
    gcxn = conn.connect()
    gmcxn = meta_conn.connect()

    # Initialize variables
    # ---------------------
    not_run = []  # type: L[str] ### List of Rules that were not run
    err_tot = 0  # total # of failed generators
    start_flag = False if start else True
    until_flag = True
    start_test = Test(lambda _, __: start_flag, lambda _: &#39;Excluded because of &#34;start&#34;&#39;)
    until_test = Test(lambda _, __: until_flag, lambda _: &#39;Excluded because of &#34;until&#34;&#39;)
    testdict = {xTest: [xclude_], start_test: [None], until_test: [None]}

    objs = {oname: (o.id_str, o.ids(), o.id_fks()) for oname, o in self.objs.items()}

    def update_run_status(status: str) -&gt; None:
        update_run_status = &#34;&#34;&#34;UPDATE run SET status=%s WHERE run_id=%s&#34;&#34;&#34;
        sqlexecute(gmcxn, update_run_status, [status, run_id])

    # Set status to running
    update_run_status(&#34;running&#34;)
    with tqdm(total=len(self.gens), position=0, disable=not bar) as tq:
        for gen in self.ordered_gens():

            # Initialize Variables
            # ---------------------
            name = gen.name
            tq.set_description(name)
            run_logger.info(f&#34;Running {gen.name}...&#34;)

            # Set flags
            # --------------------------------
            if name == start:
                start_flag = True

            # Run tests to see whether or not the Generator should be run
            if only:  # only trumps everything else, if it&#39;s defined
                run = (onlyTest(gen, only_) is True) and (xTest(gen, xclude_) is True)
            else:
                run = True  # flag for passing all tests
                for test, args in testdict.items():
                    test_output = test(gen, *args)  # type: ignore
                    if test_output is not True:
                        not_run.append(name)
                        gen.update_status(gmcxn, run_id, test_output)
                        run = False
                        break
            if run:
                try:
                    err_tot += self._run_gen(
                        objs=objs,
                        gen=gen,
                        gmcxn=gmcxn,
                        gcxn=gcxn,
                        mconn_info=meta_conn,
                        conn_info=conn,
                        run_id=run_id,
                        retry=retry,
                        serial=serial,
                        bar=bar,
                        user_batch_size=batch,
                        skip_row_count=skip_row_count,
                    )
                except (Exception, KeyboardInterrupt, SystemExit, BdbQuit) as exc:
                    # If a critical error is hit that doesn&#39;t raise
                    # ExternalError() we need to clean up
                    # Update the run
                    update_run_status(&#34;failed&#34;)
                    # Update the Gen
                    error = str(exc) if str(exc) else repr(exc)
                    gen.update_status(gmcxn, run_id, &#34;failed&#34;, err=error)
                    raise

            tq.update()

            # Set flags
            # ----------
            if name == until:
                until_flag = False

    end = &#34;&#34;&#34;UPDATE run SET delta=EXTRACT(EPOCH FROM age(CURRENT_TIMESTAMP,starttime)),
                            status=&#39;completed&#39;,
                            errs = %s
             WHERE run_id=%s&#34;&#34;&#34;

    sqlexecute(gmcxn, end, [err_tot, run_id])
    self.check_paths(conn)

    if clean:
        for o in self.objs:
            for c in [&#34;deleted&#34;]:
                q = &#34;ALTER TABLE {} DROP COLUMN {}&#34;.format(o, c)
                sqlexecute(gcxn, q)

    gcxn.close()
    gmcxn.close()
    if bar:
        run_logger.info(
            &#34;\nFinished.\n\t&#34;
            + (&#34;did not run %s&#34; % not_run if not_run else &#34;Ran all Rules&#34;)
        )


def validate_name(self: &#34;Model&#34;, w: str) -&gt; None:
    &#34;&#34;&#34;
    Checks to make sure name - in an argument of model.run() - is valid,
    If not, throws error and suggests alternatives
    &#34;&#34;&#34;
    match = False
    close = []

    def t(u: Gen) -&gt; L[str]:
        return [u.name] + u.tags

    for n in concat_map(t, list(self.gens.values())):
        d = levenshteinDistance(w, n)
        upW, upN = max(len(w), 5), max(len(n), 5)  # variables for safe indexing
        if d == 0:
            match = True
            break
        elif d &lt; 5 or w[:upW] == n[:upN]:
            close.append(n)  # keep track of near-misses
    if not match:
        did_you = &#34;Did you mean %s&#34; % close if close else &#34;&#34;
        raise ValueError(&#34;No match found for %s\n%s&#34; % (w, did_you))


def check_patheq(self: &#34;Model&#34;, p: PathEQ, db: ConnI) -&gt; None:
    &#34;&#34;&#34;
    Check whether a given database enforces the a path equality specification
    &#34;&#34;&#34;
    paths = list(p)
    ids = {n: o.id_str for n, o in self.objs.items()}
    p1, p2 = paths
    sels = p1.select(self), p2.select(self)
    joins = map(&#34;\n\t&#34;.join, (p1.joins(ids, self), p2.joins(ids, self)))
    start = p1.start()
    st_id = self[start].id_str

    q = &#34;&#34;&#34;
        SELECT &#34;{0}&#34;.&#34;{1}&#34;,
               {2},
               {3}
        FROM {0} AS &#34;{0}&#34;
        {4}
        {5}
        &#34;&#34;&#34;
    args = [start, st_id, *sels, *joins]
    query = q.format(*args)
    out = sqlselect(db.connect(), query)
    for id, a, b in out:
        if a != b:
            err = &#34;Path Equality check FAILED for {} # {}&#34; + &#34;\n{} -&gt; {}&#34; * 2
            eargs = (start, id, p1, a, p2, b)
            raise ValueError(err.format(*eargs))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dbgen.core.model.run.check_patheq"><code class="name flex">
<span>def <span class="ident">check_patheq</span></span>(<span>self: Model, p: <a title="dbgen.core.schema.PathEQ" href="../schema.html#dbgen.core.schema.PathEQ">PathEQ</a>, db: <a title="dbgen.core.misc.ConnectInfo" href="../misc.html#dbgen.core.misc.ConnectInfo">ConnectInfo</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether a given database enforces the a path equality specification</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_patheq(self: &#34;Model&#34;, p: PathEQ, db: ConnI) -&gt; None:
    &#34;&#34;&#34;
    Check whether a given database enforces the a path equality specification
    &#34;&#34;&#34;
    paths = list(p)
    ids = {n: o.id_str for n, o in self.objs.items()}
    p1, p2 = paths
    sels = p1.select(self), p2.select(self)
    joins = map(&#34;\n\t&#34;.join, (p1.joins(ids, self), p2.joins(ids, self)))
    start = p1.start()
    st_id = self[start].id_str

    q = &#34;&#34;&#34;
        SELECT &#34;{0}&#34;.&#34;{1}&#34;,
               {2},
               {3}
        FROM {0} AS &#34;{0}&#34;
        {4}
        {5}
        &#34;&#34;&#34;
    args = [start, st_id, *sels, *joins]
    query = q.format(*args)
    out = sqlselect(db.connect(), query)
    for id, a, b in out:
        if a != b:
            err = &#34;Path Equality check FAILED for {} # {}&#34; + &#34;\n{} -&gt; {}&#34; * 2
            eargs = (start, id, p1, a, p2, b)
            raise ValueError(err.format(*eargs))</code></pre>
</details>
</dd>
<dt id="dbgen.core.model.run.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self: Model, conn: <a title="dbgen.core.misc.ConnectInfo" href="../misc.html#dbgen.core.misc.ConnectInfo">ConnectInfo</a>, meta_conn: <a title="dbgen.core.misc.ConnectInfo" href="../misc.html#dbgen.core.misc.ConnectInfo">ConnectInfo</a>, nuke: str = '', add: bool = False, retry: bool = False, only: str = '', xclude: str = '', start: str = '', until: str = '', serial: bool = False, bar: bool = True, clean: bool = False, skip_row_count: bool = False, batch: int = None, write_logs: bool = False, log_level: int = 20, log_path: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is point of the model: to run and generate a database according
to the model's specified rules.</p>
<ul>
<li>conn/meta_conn: information to connect to database and logging database</li>
<li>nuke: By default, this is not used. If "True"/"T", everything except generators
tagged "no_nuke" are purged. Otherwise, give a space separated list
of generator names/tags. If a generator is purged, then any
tables it populates will be truncated. Any columns it populates will be set all
to NULL. Any generators with inputs OR outputs that have any overlap with the outputs
of a purged generator will be purged themselves.</li>
<li>add: needed if new entities/columns have been added to the model (but not yet in DB)</li>
<li>retry: ignore repeat checking</li>
<li>only: only run generators with these names (or these tags)</li>
<li>xclude: do not run generators with these names (or these tags)</li>
<li>start: start at the generator with this name</li>
<li>until: stop at the generator with this name</li>
<li>serial: force all Generators to be run without parallelization</li>
<li>bar: show progress bars</li>
<li>skip_row_count: Skip the select count(1) for all gens (good for large queries)</li>
<li>clean: 'cleans up' implementation detail columns (deleted) for
presentation of the resulting database to others&hellip;at the cost of not being
able to call model.run() without nuking again (unless an 'unclean' method is
written, which is in principle possible)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(
    self: &#34;Model&#34;,
    conn: ConnI,
    meta_conn: ConnI,
    nuke: str = &#34;&#34;,
    add: bool = False,
    retry: bool = False,
    only: str = &#34;&#34;,
    xclude: str = &#34;&#34;,
    start: str = &#34;&#34;,
    until: str = &#34;&#34;,
    serial: bool = False,
    bar: bool = True,
    clean: bool = False,
    skip_row_count: bool = False,
    batch: int = None,
    write_logs: bool = False,
    log_level: int = logging.INFO,
    log_path: str = None,
) -&gt; None:
    &#34;&#34;&#34;
    This method is point of the model: to run and generate a database according
    to the model&#39;s specified rules.

    - conn/meta_conn: information to connect to database and logging database
    - nuke: By default, this is not used. If &#34;True&#34;/&#34;T&#34;, everything except generators
            tagged &#34;no_nuke&#34; are purged. Otherwise, give a space separated list
            of generator names/tags. If a generator is purged, then any
            tables it populates will be truncated. Any columns it populates will be set all
            to NULL. Any generators with inputs OR outputs that have any overlap with the outputs
            of a purged generator will be purged themselves.
    - add: needed if new entities/columns have been added to the model (but not yet in DB)
    - retry: ignore repeat checking
    - only: only run generators with these names (or these tags)
    - xclude: do not run generators with these names (or these tags)
    - start: start at the generator with this name
    - until: stop at the generator with this name
    - serial: force all Generators to be run without parallelization
    - bar: show progress bars
    - skip_row_count: Skip the select count(1) for all gens (good for large queries)
    - clean: &#39;cleans up&#39; implementation detail columns (deleted) for
    presentation of the resulting database to others...at the cost of not being
    able to call model.run() without nuking again (unless an &#39;unclean&#39; method is
    written, which is in principle possible)

    &#34;&#34;&#34;

    # Run tests on pyblocks
    # ----------------------
    self.test_funcs()

    # # Setup logger and config
    # # --------------------
    path_to_log = log_path or default_log_path
    setup_logger(&#34;dbgen&#34;, log_level, write_logs=write_logs, log_path=Path(path_to_log))
    run_logger = logging.getLogger(&#34;dbgen.run&#34;)

    # Print to-do list for the model
    # ---------------------------------------
    todo = self._todo()
    if todo:
        run_logger.warning(
            &#34;WARNING: the following attributes do not have any generator &#34;
            &#34;to populate them: \n\t-&#34; + &#34;\n\t-&#34;.join(sorted(todo))
        )

    # Validate input
    # ----------------
    assert conn != meta_conn, &#34;Main DB cannot be in same schema as logging DB&#34;
    startErr = &#39;Starting generator (&#34;start&#34;) must be a Generator name&#39;
    assert not start or start in self.gens, startErr
    xclude_ = set(xclude.split())
    only_ = set(only.split())
    for w in only_ | xclude_:
        self._validate_name(w)

    # # Make sure no existing cxns to database
    # # ---------------------------------------
    # conn.kill()
    # meta_conn.kill()

    # Make metatables
    # ----------------
    run_id = self._make_metatables(
        mconn=meta_conn,
        conn=conn,
        nuke=nuke,
        retry=retry,
        only=&#34; &#34;.join(sorted(only_)),
        xclude=&#34; &#34;.join(sorted(xclude_)),
        start=start,
        until=until,
        bar=bar,
    )

    # Clean up database
    # -----------------
    if nuke:
        if nuke.lower() in [&#34;t&#34;, &#34;true&#34;]:
            self.make_schema(conn=conn, nuke=nuke, bar=bar)  # FULL NUKE
        else:
            raise NotImplementedError(&#34;Selective nuking is not working yet&#34;)
            deltags = set(nuke.split())
            delgens = set()
            for gen in self.ordered_gens():
                if set([gen.name] + gen.tags).intersection(deltags):
                    delgens.add(gen.name)
            for gen in self.ordered_gens():
                if gen.name in delgens:
                    gen.purge(conn.connect(), meta_conn.connect())
    elif add:
        msg = &#34;&#34;&#34;
#######################################################################
!!!WARNING!!!!
Add is an extremely experimental feature. Existing rows in
modified tables are not deleted. If you added ID info to a table then
you need to manually truncate that table (and cascade to linked tables)
or else those tables will contain rows with missing ID info in their PKs.

Add should really only be used to add attributes to existing tables
or add new empty tables. Adding identifying FKs from existing tables to new tables
is very dangerous and manual truncation will be necessary.

I hope you know what you are doing!!!
!!!WARNING!!!!
#######################################################################
        &#34;&#34;&#34;
        run_logger.warning(msg)
        for ta in tqdm(self.objs.values(), desc=&#34;Adding new tables&#34;, leave=False):
            for sqlexpr in ta.create():
                try:
                    sqlexecute(conn.connect(), sqlexpr)
                except Error as e:
                    # Error code for duplicate table
                    if e.pgcode == &#34;42701&#34;:
                        run_logger.debug(&#34;dup&#34;)
                        pass
                    # Error code for when a relation doesn&#39;t exist on a table we
                    # are adding
                    elif re.match(
                        &#39;column &#34;\w+&#34; of relation &#34;\w+&#34; does not exist&#39;, str(e)
                    ):
                        run_logger.debug(f&#34;PGERROR: {e}&#34;)
                        pass
                    else:
                        raise Error(e)
        for v in tqdm(self.viewlist, desc=&#34;Adding new views&#34;, leave=False):
            try:
                sqlexecute(conn.connect(), v.create())
            except Error as e:
                # Error code for duplicate table
                if &#34;already exists&#34; in str(e):
                    run_logger.debug(&#34;dup&#34;)
                    pass
                else:
                    raise Error(e)

        for ta in tqdm(self.objs.values(), desc=&#34;Adding new columns&#34;, leave=False):
            for sqlexpr in self.add_cols(ta):
                try:
                    sqlexecute(conn.connect(), sqlexpr)
                except Error as e:
                    # Error code for duplicate column
                    if e.pgcode == &#34;42701&#34;:
                        pass
                    else:
                        raise Error(e)

    # Make &#39;global&#39; database connections (active throughout whole process)
    # ----------------------------------------------------------------------
    gcxn = conn.connect()
    gmcxn = meta_conn.connect()

    # Initialize variables
    # ---------------------
    not_run = []  # type: L[str] ### List of Rules that were not run
    err_tot = 0  # total # of failed generators
    start_flag = False if start else True
    until_flag = True
    start_test = Test(lambda _, __: start_flag, lambda _: &#39;Excluded because of &#34;start&#34;&#39;)
    until_test = Test(lambda _, __: until_flag, lambda _: &#39;Excluded because of &#34;until&#34;&#39;)
    testdict = {xTest: [xclude_], start_test: [None], until_test: [None]}

    objs = {oname: (o.id_str, o.ids(), o.id_fks()) for oname, o in self.objs.items()}

    def update_run_status(status: str) -&gt; None:
        update_run_status = &#34;&#34;&#34;UPDATE run SET status=%s WHERE run_id=%s&#34;&#34;&#34;
        sqlexecute(gmcxn, update_run_status, [status, run_id])

    # Set status to running
    update_run_status(&#34;running&#34;)
    with tqdm(total=len(self.gens), position=0, disable=not bar) as tq:
        for gen in self.ordered_gens():

            # Initialize Variables
            # ---------------------
            name = gen.name
            tq.set_description(name)
            run_logger.info(f&#34;Running {gen.name}...&#34;)

            # Set flags
            # --------------------------------
            if name == start:
                start_flag = True

            # Run tests to see whether or not the Generator should be run
            if only:  # only trumps everything else, if it&#39;s defined
                run = (onlyTest(gen, only_) is True) and (xTest(gen, xclude_) is True)
            else:
                run = True  # flag for passing all tests
                for test, args in testdict.items():
                    test_output = test(gen, *args)  # type: ignore
                    if test_output is not True:
                        not_run.append(name)
                        gen.update_status(gmcxn, run_id, test_output)
                        run = False
                        break
            if run:
                try:
                    err_tot += self._run_gen(
                        objs=objs,
                        gen=gen,
                        gmcxn=gmcxn,
                        gcxn=gcxn,
                        mconn_info=meta_conn,
                        conn_info=conn,
                        run_id=run_id,
                        retry=retry,
                        serial=serial,
                        bar=bar,
                        user_batch_size=batch,
                        skip_row_count=skip_row_count,
                    )
                except (Exception, KeyboardInterrupt, SystemExit, BdbQuit) as exc:
                    # If a critical error is hit that doesn&#39;t raise
                    # ExternalError() we need to clean up
                    # Update the run
                    update_run_status(&#34;failed&#34;)
                    # Update the Gen
                    error = str(exc) if str(exc) else repr(exc)
                    gen.update_status(gmcxn, run_id, &#34;failed&#34;, err=error)
                    raise

            tq.update()

            # Set flags
            # ----------
            if name == until:
                until_flag = False

    end = &#34;&#34;&#34;UPDATE run SET delta=EXTRACT(EPOCH FROM age(CURRENT_TIMESTAMP,starttime)),
                            status=&#39;completed&#39;,
                            errs = %s
             WHERE run_id=%s&#34;&#34;&#34;

    sqlexecute(gmcxn, end, [err_tot, run_id])
    self.check_paths(conn)

    if clean:
        for o in self.objs:
            for c in [&#34;deleted&#34;]:
                q = &#34;ALTER TABLE {} DROP COLUMN {}&#34;.format(o, c)
                sqlexecute(gcxn, q)

    gcxn.close()
    gmcxn.close()
    if bar:
        run_logger.info(
            &#34;\nFinished.\n\t&#34;
            + (&#34;did not run %s&#34; % not_run if not_run else &#34;Ran all Rules&#34;)
        )</code></pre>
</details>
</dd>
<dt id="dbgen.core.model.run.validate_name"><code class="name flex">
<span>def <span class="ident">validate_name</span></span>(<span>self: Model, w: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks to make sure name - in an argument of model.run() - is valid,
If not, throws error and suggests alternatives</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_name(self: &#34;Model&#34;, w: str) -&gt; None:
    &#34;&#34;&#34;
    Checks to make sure name - in an argument of model.run() - is valid,
    If not, throws error and suggests alternatives
    &#34;&#34;&#34;
    match = False
    close = []

    def t(u: Gen) -&gt; L[str]:
        return [u.name] + u.tags

    for n in concat_map(t, list(self.gens.values())):
        d = levenshteinDistance(w, n)
        upW, upN = max(len(w), 5), max(len(n), 5)  # variables for safe indexing
        if d == 0:
            match = True
            break
        elif d &lt; 5 or w[:upW] == n[:upN]:
            close.append(n)  # keep track of near-misses
    if not match:
        did_you = &#34;Did you mean %s&#34; % close if close else &#34;&#34;
        raise ValueError(&#34;No match found for %s\n%s&#34; % (w, did_you))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dbgen.core.model" href="index.html">dbgen.core.model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dbgen.core.model.run.check_patheq" href="#dbgen.core.model.run.check_patheq">check_patheq</a></code></li>
<li><code><a title="dbgen.core.model.run.run" href="#dbgen.core.model.run.run">run</a></code></li>
<li><code><a title="dbgen.core.model.run.validate_name" href="#dbgen.core.model.run.validate_name">validate_name</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>