<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>dbgen.core.schema API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dbgen.core.schema</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># External
from typing import (
    Any,
    TYPE_CHECKING,
    Set as S,
    List as L,
    Dict as D,
    Tuple as T,
    Callable as C,
    Iterator as Iter,
)
from abc import ABCMeta, abstractmethod
from hypothesis.strategies import SearchStrategy, builds, lists, composite, just
from hypothesis import infer


from dbgen.core.expr.sqltypes import SQLType, Int
from dbgen.core.action import Action
from dbgen.core.misc import Dep
from dbgen.core.expr.expr import PK
from dbgen.core.pathconstraint import Path as AP
from dbgen.core.funclike import Arg, PyBlock, Const
from dbgen.utils.misc import Base, letters
from dbgen.utils.sql import (
    Connection as Conn,
    mkSelectCmd,
    sqlselect,
    mkInsCmd,
    sqlexecute,
)

# Internal
if TYPE_CHECKING:
    from dbgen.core.model.model import Model
    from dbgen.core.query import Query
    from dbgen.core.schemaclass import Schema
    from dbgen.core.expr.pathattr import PathAttr

    Model, Query, Schema, PathAttr
&#34;&#34;&#34;
Components of a schema: Objects, Attributes, and Relations

Also the RelTup container class is defined
&#34;&#34;&#34;
########################################################################################
######################
# Simple Tuple types #
######################


class AttrTup(Base):
    def __init__(self, name: str, obj: str) -&gt; None:
        self.name = name
        self.obj = obj
        super().__init__()

    def __str__(self) -&gt; str:
        return self.name + &#34;.&#34; + self.obj

    def __call__(self, x: AP = None) -&gt; &#34;PathAttr&#34;:
        from dbgen.core.expr.pathattr import PathAttr

        return PathAttr(x, self)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)


class RelTup(Base):
    &#34;&#34;&#34;
    A tuple (objectname, relationname) that an object can produce independent
    of a Model instance .... it will later have to be validated by the model to
    be a relation that actually exists, but lower level classes can work with it
    in the meantime
    &#34;&#34;&#34;

    def __init__(self, obj: str, rel: str) -&gt; None:
        self.obj = obj.lower()
        self.rel = rel.lower()
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;Rel(%s,%s)&#34; % (self.obj, self.rel)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)


################################################################################
class Attr(Base):
    &#34;&#34;&#34; Attribute, considered from a schema-making perspective (NOT as an Expr) &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        dtype: SQLType = None,
        identifying: bool = False,
        default: Any = None,
        desc: str = &#34;&lt;No description&gt;&#34;,
        index: bool = False,
    ) -&gt; None:
        assert name
        self.name = name.lower()
        self.desc = desc
        self.dtype = dtype or Int()
        self.identifying = identifying
        self.index = index
        self.default = default
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;Attr&lt;%s,%s&gt;&#34; % (self.name, self.dtype)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(Attr, name=letters, identifying=infer, desc=infer, dtype=infer)

    ####################
    # Public methods #
    ####################

    def create_col(self, tabname: str) -&gt; T[str, str, str]:
        &#34;&#34;&#34;
        Create statement for column when creating a table.
        &#34;&#34;&#34;
        dt = str(self.dtype)
        dflt = &#34;&#34; if self.default is None else &#34;DEFAULT %s&#34; % (self.default)
        desc = &#39;comment on column &#34;{}&#34;.&#34;{}&#34; is \&#39;{}\&#39;&#39;.format(
            tabname, self.name, self.desc.replace(&#34;&#39;&#34;, &#34;&#39;&#39;&#34;)
        )

        fmt_args = [self.name, dt, dflt]
        create = &#39;&#34;{}&#34; \t{} {}&#39;.format(*fmt_args)
        index = (
            f&#39;\nCREATE INDEX IF NOT EXISTS {tabname}_{self.name}_idx ON {tabname} (&#34;{self.name}&#34;)&#39;
            if self.index
            else &#34;&#34;
        )
        return create, desc, index


class View(Base, metaclass=ABCMeta):
    def __str__(self) -&gt; str:
        return &#34;View(%s)&#34; % (self.name)

    name = &#34;&#34;

    @abstractmethod
    def dep(self) -&gt; Dep:
        raise NotImplementedError

    @abstractmethod
    def qstr(self) -&gt; str:
        &#34;&#34;&#34;String representing the query (either JSON or raw SQL)&#34;&#34;&#34;
        raise NotImplementedError

    def add(self, cxn: Conn) -&gt; int:
        &#34;&#34;&#34;add view to metadb, return PK&#34;&#34;&#34;
        # Try to find an Object with an equivalent hash in the existing table
        get_v = mkSelectCmd(&#34;view&#34;, [&#34;view_id&#34;], [&#34;view_id&#34;])
        v_id = sqlselect(cxn, get_v, [self.hash])

        if v_id:
            return v_id[0][0]  # already there
        else:
            # Create a new record in the View table and get its ID
            cmd = mkInsCmd(&#34;view&#34;, [&#34;view_id&#34;, &#34;name&#34;, &#34;query&#34;])
            sqlexecute(cxn, cmd, [self.hash, self.name, self.qstr()])
            return sqlselect(cxn, get_v, [self.hash])[0][0]

    @classmethod
    @abstractmethod
    def _strat(cls) -&gt; SearchStrategy:
        raise NotImplementedError

    def create(self) -&gt; str:
        &#34;&#34;&#34;
        Generate SQL necessary to create an object&#39;s corresponding table
        &#34;&#34;&#34;
        return &#34;CREATE VIEW {} AS {}&#34;.format(self.name, self.qstr())


class QView(View):
    def __init__(self, name: str, q: &#34;Query&#34;) -&gt; None:
        self.name = name
        self.q = q

    def qstr(self) -&gt; str:
        return self.q.toJSON()

    def dep(self) -&gt; Dep:
        cd = [&#34;%s.%s&#34; % (a.obj, a.name) for a in self.q.allattr()]
        nc = [&#34;%s.%s&#34; % (self.name, x) for x in self.q.exprs]
        return Dep(self.q.allobj(), cd, [self.name], nc)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)


class RawView(View):
    def __init__(
        self, name: str, q: str, deps: L[str] = None, new: L[str] = None
    ) -&gt; None:
        self.name = name
        self.raw = q
        self.deps = deps or []
        self.new = new or []

    def qstr(self) -&gt; str:
        return self.raw

    def dep(self) -&gt; Dep:
        td = [d for d in self.deps if &#34;.&#34; not in d]
        cd = [d for d in self.deps if &#34;.&#34; in d]
        nc = [&#34;%s.%s&#34; % (self.name, x) for x in self.new]
        return Dep(td, cd, [self.name], nc)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)


class UserRel(Base):
    &#34;&#34;&#34;
    USER EXPOSED Relation between objects. no need to specify source, as it is
    declared from within the UserObj constructor.
    Can be identifying or non-identifying
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        tar: str = None,
        identifying: bool = False,
        desc: str = &#34;&lt;No description&gt;&#34;,
    ) -&gt; None:
        self.name = name.lower()
        self.desc = desc
        self.tar = tar.lower() if tar else self.name
        self.identifying = identifying
        super().__init__()

    def __str__(self) -&gt; str:
        idstr = &#34;(id)&#34; if self.identifying else &#34;&#34;
        return &#34;{}{} -&gt; {}&#34;.format(self.name, idstr, self.tar)

    def to_rel(self, obj: str) -&gt; &#34;Rel&#34;:
        return Rel(
            name=self.name,
            o1=obj,
            o2=self.tar,
            identifying=self.identifying,
            desc=self.desc,
        )

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)


class Obj(Base):
    &#34;&#34;&#34;Object with attributes. Basic entity of a model&#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        desc: str = None,
        attrs: L[Attr] = None,
        fks: L[UserRel] = None,
        id_str: str = None,
    ) -&gt; None:

        self.name = name.lower()
        self.desc = desc or &#34;&lt;No description&gt;&#34;
        self.attrs = attrs or []
        self.fks = fks or []
        self.id_str = id_str if id_str else self.name + &#34;_id&#34;
        # Validate
        self.forbidden = [self.id_str, &#34;deleted&#34;, self.name]  # RESERVED
        assert not any([a.name in self.forbidden for a in self.attrs]), (
            self.attrs,
            self.forbidden,
        )
        attr_names = [a.name for a in self.attrs]
        assert len(attr_names) == len(
            set(attr_names)
        ), f&#34;No duplicate column names allowed, \nObject: {self.name}&#34;
        assert all([isinstance(x, str) for x in [self.name, self.desc, self.id_str]])
        super().__init__()

    @property
    def attrdict(self) -&gt; D[str, Attr]:
        return {a.name: a for a in self.attrs}

    @property
    def fkdict(self) -&gt; D[str, &#34;Rel&#34;]:
        return {r.name: r.to_rel(self.name) for r in self.fks}

    @classmethod
    @composite
    def _strat(
        draw: C,
        cls: &#34;Obj&#34;,
        name: str = None,
        attrs: L[str] = None,
        fks: L[T[str, str]] = None,
    ) -&gt; SearchStrategy:
        MIN_ATTR, MAX_ATTR = [0, 2] if attrs is None else [len(attrs)] * 2
        MIN_FK, MAX_FK = [0, 2] if fks is None else [len(fks)] * 2
        size = 1 + MAX_ATTR + MAX_FK

        xx = draw(
            lists(letters, min_size=size, max_size=size, unique=True).filter(
                lambda x: name not in x
            )
        )
        attrlist = draw(lists(Attr._strat(), min_size=MIN_ATTR, max_size=MAX_ATTR))
        for i, a in enumerate(attrlist):
            a.name = attrs[i] if attrs is not None else xx[1 + i]
        fklist = draw(lists(UserRel._strat(), min_size=MIN_FK, max_size=MAX_FK))
        for i, f, in enumerate(fklist):
            f.name, f.tar = (
                fks[i]
                if fks is not None
                else (xx[1 + MAX_ATTR + i], xx[1 + MAX_ATTR + i])
            )
        b = builds(
            cls,
            name=just(name if name else xx[0]),
            desc=infer,
            attrs=just(attrs),
            fks=just(fklist),
        )
        return draw(b)

    def __str__(self) -&gt; str:
        return &#34;Object&lt;%s, %d attrs&gt;&#34; % (self.name, len(self.attrs))

    def __call__(self, **kwargs: Any) -&gt; Action:
        &#34;&#34;&#34;
        Construct an Action which specifies AT LEAST how to identify this
        object (via PK or data) AND POSSIBLY more non-identifying info to update

        - Attributes and relations are referred to by name with kwargs
        - A keyword equal to the object&#39;s own name signifies a PK argument
        &#34;&#34;&#34;
        kwargs = {k.lower(): v for k, v in kwargs.items()}  # convert keys to L.C.
        pk = kwargs.pop(self.name, None)
        insert = kwargs.pop(&#34;insert&#34;, False)

        if not pk:  # if we don&#39;t have a PK reference
            err = (
                &#34;Cannot refer to a row in {} without a PK or essential data.&#34;
                &#34; Missing essential data: {}&#34;
            )
            missing = set(self.ids()) - set(kwargs)
            assert not missing, err.format(self.name, missing)

        attrs = {k: v for k, v in kwargs.items() if k in self.attrnames()}

        fks = {k: v for k, v in kwargs.items() if k not in attrs}
        for fk in fks:
            assert fk in self.fkdict, &#39;unknown &#34;%s&#34; kwarg in Action of %s&#39; % (fk, self)
        for k, v in fks.items():
            if not isinstance(v, Action):
                # We OUGHT have a reference to a FK from a query
                try:
                    assert isinstance(v, (Arg, Const))
                except AssertionError:
                    import pdb

                    pdb.set_trace()
                rel = self.fkdict[k]
                # Check for relations with names that are different from table_names
                if rel.o2 != k:
                    fks[k] = Action(obj=rel.o2, attrs={}, fks={}, pk=v)
                else:
                    fks[k] = Action(obj=k, attrs={}, fks={}, pk=v)

        return Action(self.name, attrs=attrs, fks=fks, pk=pk, insert=insert)

    def __getitem__(self, key: str) -&gt; AttrTup:
        if key in self.attrdict:
            return AttrTup(key, self.name)
        else:
            raise KeyError(key + &#34; not found in %s&#34; % self)

    # Public methods #

    def get(self, key: str) -&gt; AttrTup:
        &#34;&#34;&#34;
        A version of __getitem__ that doesn&#39;t check whether attribute is defined
        Use when we need to refer to an attribute which may not (yet) exist
        &#34;&#34;&#34;
        return AttrTup(key, self.name)

    def act(self, **kwargs: Any) -&gt; Action:
        &#39;&#39;&#39;Do we need to add a &#34;insert&#34; flag in order to say: &#34;it&#39;s ok for this
        action to insert any required parent objects recursively?&#34;&#39;&#39;&#39;
        return self(**kwargs)

    def add_attrs(self, ats: L[Attr]) -&gt; None:
        for a in ats:
            assert a.name not in self.attrs or a.name in self.forbidden, (
                a.name,
                self.attrs,
                self.forbidden,
            )
        self.attrs.extend(ats)

    def del_attrs(self, ats: L[str]) -&gt; None:
        self.attrs = [a for a in self.attrs if a.name not in ats]

    def r(self, relname: str) -&gt; RelTup:
        &#34;&#34;&#34;
        Refer to a relation of an object. Without a Model, we have to do with
        reference by name
        &#34;&#34;&#34;
        return RelTup(self.name, relname)

    def attrnames(self, init: bool = False) -&gt; L[str]:
        &#34;&#34;&#34;Names of all (top-level) attributes&#34;&#34;&#34;
        return [a.name for a in self.attrs if a.identifying or not init]

    def create(self) -&gt; L[str]:
        &#34;&#34;&#34;
        Generate SQL necessary to create an object&#39;s corresponding table
        &#34;&#34;&#34;
        create_str = &#39;CREATE TABLE IF NOT EXISTS &#34;%s&#34; &#39; % self.name
        if len(self.attrs) != 0:
            cols, coldescs, colindexes = zip(
                *[a.create_col(self.name) for a in self.attrs]
            )
        else:
            cols, coldescs, colindexes = [], [], []
        pk = self.id_str + &#34; BIGINT PRIMARY KEY &#34;
        deld = &#34;deleted BOOLEAN NOT NULL DEFAULT FALSE&#34;
        full_cols = [pk, deld] + list(cols)

        tabdesc = &#34;comment on table \&#34;{}\&#34; is &#39;{}&#39;&#34;.format(
            self.name, self.desc.replace(&#34;&#39;&#34;, &#34;&#39;&#39;&#34;)
        )
        fmt_args = [create_str, &#34;\n\t,&#34;.join(full_cols)]
        cmd = &#34;{}\n\t({})&#34;.format(*fmt_args)
        sqls = (
            [cmd, tabdesc]
            + list(coldescs)
            + list(filter(lambda x: x != &#34;&#34;, colindexes))
        )
        return sqls

    def id(self, path: AP = None) -&gt; PK:
        &#34;&#34;&#34;Main use case: GROUP BY an object, rather than a particular column&#34;&#34;&#34;
        from dbgen.core.expr.pathattr import PathAttr

        return PK(PathAttr(path, AttrTup(self.id_str, self.name)))

    def ids(self) -&gt; L[str]:
        &#34;&#34;&#34;Names of all the identifying (top-level) attributes.&#34;&#34;&#34;
        return [a.name for a in self.attrs if a.identifying]

    def id_fks(self) -&gt; L[str]:
        &#34;&#34;&#34;Names of all the identifying (top-level) FKs &#34;&#34;&#34;
        return [f.name for f in self.fks if f.identifying]

    def add(self, cxn: Conn) -&gt; int:
        &#34;&#34;&#34;
        Add this Object to a metaDB that stores information about a model (if
        it&#39;s not already there), and return the ID.
        &#34;&#34;&#34;
        # Try to find an Object with an equivalent hash in the existing table
        get_t = mkSelectCmd(&#34;object&#34;, [&#34;object_id&#34;], [&#34;object_id&#34;])
        t_id = sqlselect(cxn, get_t, [self.hash])

        if t_id:
            return t_id[0][0]  # already there
        else:
            # Create a new record in the Object table and get its ID
            name = self.name
            cmd = mkInsCmd(&#34;object&#34;, [&#34;object_id&#34;, &#34;name&#34;, &#34;description&#34;])
            sqlexecute(cxn, cmd, [self.hash, name, self.desc])
            tab_id = sqlselect(cxn, get_t, [self.hash])[0][0]

            # Before returning ID, we have to populate Attr table
            ins_cols = [
                &#34;object&#34;,
                &#34;name&#34;,
                &#34;dtype&#34;,
                &#34;description&#34;,
                &#34;defaultval&#34;,
                &#34;attr_id&#34;,
            ]

            for c in self.attrs:
                # Insert info about an attribute
                binds = [tab_id, c.name, str(c.dtype), c.desc, str(c.default), c.hash]

                cmd = mkInsCmd(&#34;attr&#34;, ins_cols)
                sqlexecute(cxn, cmd, binds)

            return tab_id

    def rename_attr(self, aname: str, newname: str) -&gt; &#34;Obj&#34;:
        &#34;&#34;&#34; Copy of object with a renamed attribute &#34;&#34;&#34;
        o = self.copy()
        newattr = o.attrdict[aname]
        o.attrs.remove(newattr)
        newattr.name = newname
        o.attrs.append(newattr)
        return o

    def default_action(self, pb: PyBlock) -&gt; Action:
        &#34;&#34;&#34;Assuming there is some pyblock with all the info we need to insert
            this object (in some standardized naming scheme), use it to insert
            instances of this object&#34;&#34;&#34;
        raise NotImplementedError


class Rel(Base):
    &#34;&#34;&#34;
    Asymmetric Relation between objects

    Can be identifying or non-identifying
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        o1: str,
        o2: str = None,
        identifying: bool = False,
        desc: str = &#34;&lt;No description&gt;&#34;,
    ) -&gt; None:
        self.name = name.lower()
        self.desc = desc
        self.o1 = o1.lower()
        self.o2 = o2.lower() if o2 else self.name
        self.identifying = identifying
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;Rel&lt;%s%s,%s -&gt; %s&gt;&#34; % (
            self.name,
            &#34;(id)&#34; if self.identifying else &#34;&#34;,
            self.o1,
            self.o2,
        )

    def __repr__(self) -&gt; str:
        return &#34;%s__%s&#34; % (self.o1, self.name)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls, o2=infer, identifying=infer, desc=infer)

    # Public methods #

    def print(self) -&gt; str:
        return &#34;%s.%s&#34; % (self.o1, self.name)

    def tup(self) -&gt; RelTup:
        &#34;&#34;&#34;Throw away info to make a RelTup&#34;&#34;&#34;
        return RelTup(self.o1, self.name)

    @property
    def default(self) -&gt; bool:
        &#34;&#34;&#34;Whether or not this Relation is the &#39;default&#39; one&#34;&#34;&#34;
        return self.name == self.o2

    @property
    def objs(self) -&gt; S[str]:
        return set([self.o1, self.o2])

    def other(self, obj: str) -&gt; str:
        &#34;&#34;&#34;
        Often we don&#39;t know which direction we are traversing on a FK
        We know which end we&#39;re coming from and simply want the other end
        &#34;&#34;&#34;
        assert obj in self.objs, &#34;%s not found in %s&#34; % (obj, self)

        out = [o for o in self.objs if o != obj]

        if out:
            return out[0]  # normal case
        else:
            return obj  # both to and from are the same table!

    # Private Methods #
    # ...


class SuperRel(Base):
    &#34;&#34;&#34;
    Contains information about source table name, relation name,
    and target table ID column name.

    Example:
    SuperRel: Person.favorite_book &lt;-&gt; book.title
        name: favorite_book
        source: Person
        book: target
        target_id_str: Title
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        source: str,
        target: str,
        target_id_str: str,
        identifying: bool = False,
        desc: str = &#34;&lt;No description&gt;&#34;,
    ) -&gt; None:
        self.name = name.lower()
        self.source = source.lower()
        self.target = target.lower()
        self.target_id_str = target_id_str
        self.identifying = identifying
        self.desc = desc

        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;SuperRel&lt;%s,%s -&gt; %s.%s&gt;&#34; % (
            self.name,
            self.source,
            self.target,
            self.target_id_str,
        )

    def __repr__(self) -&gt; str:
        return self.__str__()

    # Public methods #

    def print(self) -&gt; str:
        return &#34;%s.%s&#34; % (self.source, self.name)

    def tup(self) -&gt; RelTup:
        &#34;&#34;&#34;Throw away info to make a RelTup&#34;&#34;&#34;
        return RelTup(self.source, self.name)

    @property
    def default(self) -&gt; bool:
        &#34;&#34;&#34;Whether or not this Relation is the &#39;default&#39; one&#34;&#34;&#34;
        return self.name == self.target

    @property
    def objs(self) -&gt; S[str]:
        return set([self.source, self.target])

    def other(self, obj: str) -&gt; str:
        &#34;&#34;&#34;
        Often we don&#39;t know which direction we are traversing on a FK
        We know which end we&#39;re coming from and simply want the other end
        &#34;&#34;&#34;
        assert obj in self.objs, &#34;%s not found in %s&#34; % (obj, self)

        out = [o for o in self.objs if o != obj]

        if out:
            return out[0]  # normal case
        else:
            return obj  # both to and from are the same table!

    def to_rel(self) -&gt; Rel:
        return Rel(self.name, self.source, self.target, self.identifying, self.desc)

    # Private Methods #
    # ...
    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)


class Path(Base):
    &#34;&#34;&#34;
    Some list of foreign keys (possibly empty), possibly followed by attribute
    &#34;&#34;&#34;

    def __init__(self, rels: L[RelTup] = None, attr: AttrTup = None) -&gt; None:
        self.rels = rels or []
        self.attr = attr
        assert rels or attr
        super().__init__()

    def __str__(self) -&gt; str:
        p = &#34;[%s]&#34; % &#34;,&#34;.join(map(str, self.rels)) if self.rels else &#34;&#34;
        comma = &#34;,&#34; if self.rels else &#34;&#34;
        a = comma + str(self.attr) if self.attr else &#34;&#34;
        return &#34;Path(%s%s)&#34; % (p, a)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(
            cls, rels=lists(RelTup._strat(), max_size=2), attr=AttrTup._strat()
        )

    def start(self) -&gt; str:
        &#34;&#34;&#34;Starting point of a path, always an object (name is returned)&#34;&#34;&#34;
        if self.rels:
            return self.rels[0].obj
        else:
            assert self.attr
            return self.attr.obj

    def select(self, m: &#34;Model&#34;) -&gt; str:
        &#34;&#34;&#34; Thing to select for when comparing path equality &#34;&#34;&#34;
        alias = self.start()
        for r in self.rels:
            alias += &#34;$&#34; + r.rel
        col = self._end_attr(m).name
        return &#39;&#34;%s&#34;.&#34;%s&#34;&#39; % (alias, col)

    def joins(self, ids: D[str, str], m: &#34;Model&#34;) -&gt; L[str]:
        &#34;&#34;&#34;From clause that makes self.select() defined in query&#34;&#34;&#34;

        j = []  # type: L[str]
        oldpath = self.start()
        jstr = &#39;JOIN &#34;{0}&#34; AS &#34;{1}&#34; ON &#34;{1}&#34;.&#34;{4}&#34; = &#34;{2}&#34;.&#34;{3}&#34;&#39;
        next = self.start()
        for i, r in enumerate(self.rels[:-1]):
            newpath = oldpath + &#34;$&#34; + r.rel
            next = self.rels[i + 1].obj
            nextid = ids[next]
            args = [next, newpath, oldpath, r.rel, nextid]
            j.append(jstr.format(*args))
            oldpath = newpath
        if self.rels:
            last = self.rels[-1].rel
            lastid = ids[m.get_rel(self.rels[-1]).o2]
            newpath = oldpath + &#34;$&#34; + last
            lastargs = [self._end_attr(m).obj, newpath, oldpath, last, lastid]
            j.append(jstr.format(*lastargs))
        return j

    def _end_attr(self, m: &#34;Model&#34;) -&gt; AttrTup:
        &#34;&#34;&#34;the ID colname if we don&#39;t have a normal attribute as terminus&#34;&#34;&#34;
        if not self.attr:
            rel = m.get_rel(self.rels[-1])
            return AttrTup(m[rel.o2].id_str, rel.o2)
        else:
            return self.attr

    def _path_end(self, m: &#34;Schema&#34;) -&gt; str:
        &#34;&#34;&#34;Determine the datatype of the end of a path.&#34;&#34;&#34;
        if (not self.attr) or (
            AttrTup(m[self.attr.obj].id_str, self.attr.obj) == self.attr
        ):
            return &#34;id&#34;
        else:
            o = m[self.attr.obj]
            a = [a for n, a in o.attrdict.items() if n == self.attr.name]
            assert len(a) &lt; 2
            if not a:
                err = &#34;Could not find %s in %s: Path %s&#34;
                import pdb

                pdb.set_trace()
                raise ValueError(err % (a, o, self))
            return str(a[0].dtype)


class PathEQ(Base):
    &#34;&#34;&#34;Specification that two paths should result in the same value.&#34;&#34;&#34;

    def __init__(self, p1: Path, p2: Path) -&gt; None:
        assert p1 != p2, &#34;Cannot do pathEQ between things that are literally equivalent&#34;
        assert p1.start() == p2.start(), &#34;Paths must have same start point&#34;
        self.paths = set([p1, p2])
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;PathEQ({},{})&#34;.format(*self.paths)

    def __iter__(self) -&gt; Iter[Path]:
        return iter(self.paths)

    def __contains__(self, a: AttrTup) -&gt; bool:
        if isinstance(a, AttrTup):
            return any([a == p.attr for p in self.paths])
        else:
            raise TypeError(&#34;add to this to support more types of searching&#34;)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls, p1=Path._strat(), p2=Path._strat())

    def any(self) -&gt; Path:
        &#34;&#34;&#34;Gives one of the paths, doesn&#39;t matter which&#34;&#34;&#34;
        return next(iter(self))

    def start(self) -&gt; str:
        return self.any().start()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dbgen.core.schema.Attr"><code class="flex name class">
<span>class <span class="ident">Attr</span></span>
<span>(</span><span>name: str, dtype: <a title="dbgen.core.expr.sqltypes.SQLType" href="expr/sqltypes.html#dbgen.core.expr.sqltypes.SQLType">SQLType</a> = None, identifying: bool = False, default: Any = None, desc: str = &#x27;&lt;No description&gt;&#x27;, index: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Attribute, considered from a schema-making perspective (NOT as an Expr)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Attr(Base):
    &#34;&#34;&#34; Attribute, considered from a schema-making perspective (NOT as an Expr) &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        dtype: SQLType = None,
        identifying: bool = False,
        default: Any = None,
        desc: str = &#34;&lt;No description&gt;&#34;,
        index: bool = False,
    ) -&gt; None:
        assert name
        self.name = name.lower()
        self.desc = desc
        self.dtype = dtype or Int()
        self.identifying = identifying
        self.index = index
        self.default = default
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;Attr&lt;%s,%s&gt;&#34; % (self.name, self.dtype)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(Attr, name=letters, identifying=infer, desc=infer, dtype=infer)

    ####################
    # Public methods #
    ####################

    def create_col(self, tabname: str) -&gt; T[str, str, str]:
        &#34;&#34;&#34;
        Create statement for column when creating a table.
        &#34;&#34;&#34;
        dt = str(self.dtype)
        dflt = &#34;&#34; if self.default is None else &#34;DEFAULT %s&#34; % (self.default)
        desc = &#39;comment on column &#34;{}&#34;.&#34;{}&#34; is \&#39;{}\&#39;&#39;.format(
            tabname, self.name, self.desc.replace(&#34;&#39;&#34;, &#34;&#39;&#39;&#34;)
        )

        fmt_args = [self.name, dt, dflt]
        create = &#39;&#34;{}&#34; \t{} {}&#39;.format(*fmt_args)
        index = (
            f&#39;\nCREATE INDEX IF NOT EXISTS {tabname}_{self.name}_idx ON {tabname} (&#34;{self.name}&#34;)&#39;
            if self.index
            else &#34;&#34;
        )
        return create, desc, index</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.schema.Attr.create_col"><code class="name flex">
<span>def <span class="ident">create_col</span></span>(<span>self, tabname: str) ‑> Tuple[str, str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Create statement for column when creating a table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_col(self, tabname: str) -&gt; T[str, str, str]:
    &#34;&#34;&#34;
    Create statement for column when creating a table.
    &#34;&#34;&#34;
    dt = str(self.dtype)
    dflt = &#34;&#34; if self.default is None else &#34;DEFAULT %s&#34; % (self.default)
    desc = &#39;comment on column &#34;{}&#34;.&#34;{}&#34; is \&#39;{}\&#39;&#39;.format(
        tabname, self.name, self.desc.replace(&#34;&#39;&#34;, &#34;&#39;&#39;&#34;)
    )

    fmt_args = [self.name, dt, dflt]
    create = &#39;&#34;{}&#34; \t{} {}&#39;.format(*fmt_args)
    index = (
        f&#39;\nCREATE INDEX IF NOT EXISTS {tabname}_{self.name}_idx ON {tabname} (&#34;{self.name}&#34;)&#39;
        if self.index
        else &#34;&#34;
    )
    return create, desc, index</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbgen.core.schema.AttrTup"><code class="flex name class">
<span>class <span class="ident">AttrTup</span></span>
<span>(</span><span>name: str, obj: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Common methods shared by many DbGen objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AttrTup(Base):
    def __init__(self, name: str, obj: str) -&gt; None:
        self.name = name
        self.obj = obj
        super().__init__()

    def __str__(self) -&gt; str:
        return self.name + &#34;.&#34; + self.obj

    def __call__(self, x: AP = None) -&gt; &#34;PathAttr&#34;:
        from dbgen.core.expr.pathattr import PathAttr

        return PathAttr(x, self)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
</dd>
<dt id="dbgen.core.schema.Obj"><code class="flex name class">
<span>class <span class="ident">Obj</span></span>
<span>(</span><span>name: str, desc: str = None, attrs: List[<a title="dbgen.core.schema.Attr" href="#dbgen.core.schema.Attr">Attr</a>] = None, fks: List[<a title="dbgen.core.schema.UserRel" href="#dbgen.core.schema.UserRel">UserRel</a>] = None, id_str: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Object with attributes. Basic entity of a model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Obj(Base):
    &#34;&#34;&#34;Object with attributes. Basic entity of a model&#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        desc: str = None,
        attrs: L[Attr] = None,
        fks: L[UserRel] = None,
        id_str: str = None,
    ) -&gt; None:

        self.name = name.lower()
        self.desc = desc or &#34;&lt;No description&gt;&#34;
        self.attrs = attrs or []
        self.fks = fks or []
        self.id_str = id_str if id_str else self.name + &#34;_id&#34;
        # Validate
        self.forbidden = [self.id_str, &#34;deleted&#34;, self.name]  # RESERVED
        assert not any([a.name in self.forbidden for a in self.attrs]), (
            self.attrs,
            self.forbidden,
        )
        attr_names = [a.name for a in self.attrs]
        assert len(attr_names) == len(
            set(attr_names)
        ), f&#34;No duplicate column names allowed, \nObject: {self.name}&#34;
        assert all([isinstance(x, str) for x in [self.name, self.desc, self.id_str]])
        super().__init__()

    @property
    def attrdict(self) -&gt; D[str, Attr]:
        return {a.name: a for a in self.attrs}

    @property
    def fkdict(self) -&gt; D[str, &#34;Rel&#34;]:
        return {r.name: r.to_rel(self.name) for r in self.fks}

    @classmethod
    @composite
    def _strat(
        draw: C,
        cls: &#34;Obj&#34;,
        name: str = None,
        attrs: L[str] = None,
        fks: L[T[str, str]] = None,
    ) -&gt; SearchStrategy:
        MIN_ATTR, MAX_ATTR = [0, 2] if attrs is None else [len(attrs)] * 2
        MIN_FK, MAX_FK = [0, 2] if fks is None else [len(fks)] * 2
        size = 1 + MAX_ATTR + MAX_FK

        xx = draw(
            lists(letters, min_size=size, max_size=size, unique=True).filter(
                lambda x: name not in x
            )
        )
        attrlist = draw(lists(Attr._strat(), min_size=MIN_ATTR, max_size=MAX_ATTR))
        for i, a in enumerate(attrlist):
            a.name = attrs[i] if attrs is not None else xx[1 + i]
        fklist = draw(lists(UserRel._strat(), min_size=MIN_FK, max_size=MAX_FK))
        for i, f, in enumerate(fklist):
            f.name, f.tar = (
                fks[i]
                if fks is not None
                else (xx[1 + MAX_ATTR + i], xx[1 + MAX_ATTR + i])
            )
        b = builds(
            cls,
            name=just(name if name else xx[0]),
            desc=infer,
            attrs=just(attrs),
            fks=just(fklist),
        )
        return draw(b)

    def __str__(self) -&gt; str:
        return &#34;Object&lt;%s, %d attrs&gt;&#34; % (self.name, len(self.attrs))

    def __call__(self, **kwargs: Any) -&gt; Action:
        &#34;&#34;&#34;
        Construct an Action which specifies AT LEAST how to identify this
        object (via PK or data) AND POSSIBLY more non-identifying info to update

        - Attributes and relations are referred to by name with kwargs
        - A keyword equal to the object&#39;s own name signifies a PK argument
        &#34;&#34;&#34;
        kwargs = {k.lower(): v for k, v in kwargs.items()}  # convert keys to L.C.
        pk = kwargs.pop(self.name, None)
        insert = kwargs.pop(&#34;insert&#34;, False)

        if not pk:  # if we don&#39;t have a PK reference
            err = (
                &#34;Cannot refer to a row in {} without a PK or essential data.&#34;
                &#34; Missing essential data: {}&#34;
            )
            missing = set(self.ids()) - set(kwargs)
            assert not missing, err.format(self.name, missing)

        attrs = {k: v for k, v in kwargs.items() if k in self.attrnames()}

        fks = {k: v for k, v in kwargs.items() if k not in attrs}
        for fk in fks:
            assert fk in self.fkdict, &#39;unknown &#34;%s&#34; kwarg in Action of %s&#39; % (fk, self)
        for k, v in fks.items():
            if not isinstance(v, Action):
                # We OUGHT have a reference to a FK from a query
                try:
                    assert isinstance(v, (Arg, Const))
                except AssertionError:
                    import pdb

                    pdb.set_trace()
                rel = self.fkdict[k]
                # Check for relations with names that are different from table_names
                if rel.o2 != k:
                    fks[k] = Action(obj=rel.o2, attrs={}, fks={}, pk=v)
                else:
                    fks[k] = Action(obj=k, attrs={}, fks={}, pk=v)

        return Action(self.name, attrs=attrs, fks=fks, pk=pk, insert=insert)

    def __getitem__(self, key: str) -&gt; AttrTup:
        if key in self.attrdict:
            return AttrTup(key, self.name)
        else:
            raise KeyError(key + &#34; not found in %s&#34; % self)

    # Public methods #

    def get(self, key: str) -&gt; AttrTup:
        &#34;&#34;&#34;
        A version of __getitem__ that doesn&#39;t check whether attribute is defined
        Use when we need to refer to an attribute which may not (yet) exist
        &#34;&#34;&#34;
        return AttrTup(key, self.name)

    def act(self, **kwargs: Any) -&gt; Action:
        &#39;&#39;&#39;Do we need to add a &#34;insert&#34; flag in order to say: &#34;it&#39;s ok for this
        action to insert any required parent objects recursively?&#34;&#39;&#39;&#39;
        return self(**kwargs)

    def add_attrs(self, ats: L[Attr]) -&gt; None:
        for a in ats:
            assert a.name not in self.attrs or a.name in self.forbidden, (
                a.name,
                self.attrs,
                self.forbidden,
            )
        self.attrs.extend(ats)

    def del_attrs(self, ats: L[str]) -&gt; None:
        self.attrs = [a for a in self.attrs if a.name not in ats]

    def r(self, relname: str) -&gt; RelTup:
        &#34;&#34;&#34;
        Refer to a relation of an object. Without a Model, we have to do with
        reference by name
        &#34;&#34;&#34;
        return RelTup(self.name, relname)

    def attrnames(self, init: bool = False) -&gt; L[str]:
        &#34;&#34;&#34;Names of all (top-level) attributes&#34;&#34;&#34;
        return [a.name for a in self.attrs if a.identifying or not init]

    def create(self) -&gt; L[str]:
        &#34;&#34;&#34;
        Generate SQL necessary to create an object&#39;s corresponding table
        &#34;&#34;&#34;
        create_str = &#39;CREATE TABLE IF NOT EXISTS &#34;%s&#34; &#39; % self.name
        if len(self.attrs) != 0:
            cols, coldescs, colindexes = zip(
                *[a.create_col(self.name) for a in self.attrs]
            )
        else:
            cols, coldescs, colindexes = [], [], []
        pk = self.id_str + &#34; BIGINT PRIMARY KEY &#34;
        deld = &#34;deleted BOOLEAN NOT NULL DEFAULT FALSE&#34;
        full_cols = [pk, deld] + list(cols)

        tabdesc = &#34;comment on table \&#34;{}\&#34; is &#39;{}&#39;&#34;.format(
            self.name, self.desc.replace(&#34;&#39;&#34;, &#34;&#39;&#39;&#34;)
        )
        fmt_args = [create_str, &#34;\n\t,&#34;.join(full_cols)]
        cmd = &#34;{}\n\t({})&#34;.format(*fmt_args)
        sqls = (
            [cmd, tabdesc]
            + list(coldescs)
            + list(filter(lambda x: x != &#34;&#34;, colindexes))
        )
        return sqls

    def id(self, path: AP = None) -&gt; PK:
        &#34;&#34;&#34;Main use case: GROUP BY an object, rather than a particular column&#34;&#34;&#34;
        from dbgen.core.expr.pathattr import PathAttr

        return PK(PathAttr(path, AttrTup(self.id_str, self.name)))

    def ids(self) -&gt; L[str]:
        &#34;&#34;&#34;Names of all the identifying (top-level) attributes.&#34;&#34;&#34;
        return [a.name for a in self.attrs if a.identifying]

    def id_fks(self) -&gt; L[str]:
        &#34;&#34;&#34;Names of all the identifying (top-level) FKs &#34;&#34;&#34;
        return [f.name for f in self.fks if f.identifying]

    def add(self, cxn: Conn) -&gt; int:
        &#34;&#34;&#34;
        Add this Object to a metaDB that stores information about a model (if
        it&#39;s not already there), and return the ID.
        &#34;&#34;&#34;
        # Try to find an Object with an equivalent hash in the existing table
        get_t = mkSelectCmd(&#34;object&#34;, [&#34;object_id&#34;], [&#34;object_id&#34;])
        t_id = sqlselect(cxn, get_t, [self.hash])

        if t_id:
            return t_id[0][0]  # already there
        else:
            # Create a new record in the Object table and get its ID
            name = self.name
            cmd = mkInsCmd(&#34;object&#34;, [&#34;object_id&#34;, &#34;name&#34;, &#34;description&#34;])
            sqlexecute(cxn, cmd, [self.hash, name, self.desc])
            tab_id = sqlselect(cxn, get_t, [self.hash])[0][0]

            # Before returning ID, we have to populate Attr table
            ins_cols = [
                &#34;object&#34;,
                &#34;name&#34;,
                &#34;dtype&#34;,
                &#34;description&#34;,
                &#34;defaultval&#34;,
                &#34;attr_id&#34;,
            ]

            for c in self.attrs:
                # Insert info about an attribute
                binds = [tab_id, c.name, str(c.dtype), c.desc, str(c.default), c.hash]

                cmd = mkInsCmd(&#34;attr&#34;, ins_cols)
                sqlexecute(cxn, cmd, binds)

            return tab_id

    def rename_attr(self, aname: str, newname: str) -&gt; &#34;Obj&#34;:
        &#34;&#34;&#34; Copy of object with a renamed attribute &#34;&#34;&#34;
        o = self.copy()
        newattr = o.attrdict[aname]
        o.attrs.remove(newattr)
        newattr.name = newname
        o.attrs.append(newattr)
        return o

    def default_action(self, pb: PyBlock) -&gt; Action:
        &#34;&#34;&#34;Assuming there is some pyblock with all the info we need to insert
            this object (in some standardized naming scheme), use it to insert
            instances of this object&#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="dbgen.core.schema.Obj.attrdict"><code class="name">var <span class="ident">attrdict</span> : Dict[str, <a title="dbgen.core.schema.Attr" href="#dbgen.core.schema.Attr">Attr</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def attrdict(self) -&gt; D[str, Attr]:
    return {a.name: a for a in self.attrs}</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.fkdict"><code class="name">var <span class="ident">fkdict</span> : Dict[str, <a title="dbgen.core.schema.Rel" href="#dbgen.core.schema.Rel">Rel</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fkdict(self) -&gt; D[str, &#34;Rel&#34;]:
    return {r.name: r.to_rel(self.name) for r in self.fks}</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.schema.Obj.act"><code class="name flex">
<span>def <span class="ident">act</span></span>(<span>self, **kwargs: Any) ‑> <a title="dbgen.core.action.Action" href="action.html#dbgen.core.action.Action">Action</a></span>
</code></dt>
<dd>
<div class="desc"><p>Do we need to add a "insert" flag in order to say: "it's ok for this
action to insert any required parent objects recursively?"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def act(self, **kwargs: Any) -&gt; Action:
    &#39;&#39;&#39;Do we need to add a &#34;insert&#34; flag in order to say: &#34;it&#39;s ok for this
    action to insert any required parent objects recursively?&#34;&#39;&#39;&#39;
    return self(**kwargs)</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, cxn: Any) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Add this Object to a metaDB that stores information about a model (if
it's not already there), and return the ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, cxn: Conn) -&gt; int:
    &#34;&#34;&#34;
    Add this Object to a metaDB that stores information about a model (if
    it&#39;s not already there), and return the ID.
    &#34;&#34;&#34;
    # Try to find an Object with an equivalent hash in the existing table
    get_t = mkSelectCmd(&#34;object&#34;, [&#34;object_id&#34;], [&#34;object_id&#34;])
    t_id = sqlselect(cxn, get_t, [self.hash])

    if t_id:
        return t_id[0][0]  # already there
    else:
        # Create a new record in the Object table and get its ID
        name = self.name
        cmd = mkInsCmd(&#34;object&#34;, [&#34;object_id&#34;, &#34;name&#34;, &#34;description&#34;])
        sqlexecute(cxn, cmd, [self.hash, name, self.desc])
        tab_id = sqlselect(cxn, get_t, [self.hash])[0][0]

        # Before returning ID, we have to populate Attr table
        ins_cols = [
            &#34;object&#34;,
            &#34;name&#34;,
            &#34;dtype&#34;,
            &#34;description&#34;,
            &#34;defaultval&#34;,
            &#34;attr_id&#34;,
        ]

        for c in self.attrs:
            # Insert info about an attribute
            binds = [tab_id, c.name, str(c.dtype), c.desc, str(c.default), c.hash]

            cmd = mkInsCmd(&#34;attr&#34;, ins_cols)
            sqlexecute(cxn, cmd, binds)

        return tab_id</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.add_attrs"><code class="name flex">
<span>def <span class="ident">add_attrs</span></span>(<span>self, ats: List[<a title="dbgen.core.schema.Attr" href="#dbgen.core.schema.Attr">Attr</a>]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_attrs(self, ats: L[Attr]) -&gt; None:
    for a in ats:
        assert a.name not in self.attrs or a.name in self.forbidden, (
            a.name,
            self.attrs,
            self.forbidden,
        )
    self.attrs.extend(ats)</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.attrnames"><code class="name flex">
<span>def <span class="ident">attrnames</span></span>(<span>self, init: bool = False) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Names of all (top-level) attributes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attrnames(self, init: bool = False) -&gt; L[str]:
    &#34;&#34;&#34;Names of all (top-level) attributes&#34;&#34;&#34;
    return [a.name for a in self.attrs if a.identifying or not init]</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate SQL necessary to create an object's corresponding table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self) -&gt; L[str]:
    &#34;&#34;&#34;
    Generate SQL necessary to create an object&#39;s corresponding table
    &#34;&#34;&#34;
    create_str = &#39;CREATE TABLE IF NOT EXISTS &#34;%s&#34; &#39; % self.name
    if len(self.attrs) != 0:
        cols, coldescs, colindexes = zip(
            *[a.create_col(self.name) for a in self.attrs]
        )
    else:
        cols, coldescs, colindexes = [], [], []
    pk = self.id_str + &#34; BIGINT PRIMARY KEY &#34;
    deld = &#34;deleted BOOLEAN NOT NULL DEFAULT FALSE&#34;
    full_cols = [pk, deld] + list(cols)

    tabdesc = &#34;comment on table \&#34;{}\&#34; is &#39;{}&#39;&#34;.format(
        self.name, self.desc.replace(&#34;&#39;&#34;, &#34;&#39;&#39;&#34;)
    )
    fmt_args = [create_str, &#34;\n\t,&#34;.join(full_cols)]
    cmd = &#34;{}\n\t({})&#34;.format(*fmt_args)
    sqls = (
        [cmd, tabdesc]
        + list(coldescs)
        + list(filter(lambda x: x != &#34;&#34;, colindexes))
    )
    return sqls</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.default_action"><code class="name flex">
<span>def <span class="ident">default_action</span></span>(<span>self, pb: <a title="dbgen.core.funclike.PyBlock" href="funclike.html#dbgen.core.funclike.PyBlock">PyBlock</a>) ‑> <a title="dbgen.core.action.Action" href="action.html#dbgen.core.action.Action">Action</a></span>
</code></dt>
<dd>
<div class="desc"><p>Assuming there is some pyblock with all the info we need to insert
this object (in some standardized naming scheme), use it to insert
instances of this object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_action(self, pb: PyBlock) -&gt; Action:
    &#34;&#34;&#34;Assuming there is some pyblock with all the info we need to insert
        this object (in some standardized naming scheme), use it to insert
        instances of this object&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.del_attrs"><code class="name flex">
<span>def <span class="ident">del_attrs</span></span>(<span>self, ats: List[str]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_attrs(self, ats: L[str]) -&gt; None:
    self.attrs = [a for a in self.attrs if a.name not in ats]</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key: str) ‑> <a title="dbgen.core.schema.AttrTup" href="#dbgen.core.schema.AttrTup">AttrTup</a></span>
</code></dt>
<dd>
<div class="desc"><p>A version of <strong>getitem</strong> that doesn't check whether attribute is defined
Use when we need to refer to an attribute which may not (yet) exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, key: str) -&gt; AttrTup:
    &#34;&#34;&#34;
    A version of __getitem__ that doesn&#39;t check whether attribute is defined
    Use when we need to refer to an attribute which may not (yet) exist
    &#34;&#34;&#34;
    return AttrTup(key, self.name)</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.id"><code class="name flex">
<span>def <span class="ident">id</span></span>(<span>self, path: <a title="dbgen.core.fromclause.Path" href="fromclause.html#dbgen.core.fromclause.Path">Path</a> = None) ‑> <a title="dbgen.core.expr.expr.PK" href="expr/expr.html#dbgen.core.expr.expr.PK">PK</a></span>
</code></dt>
<dd>
<div class="desc"><p>Main use case: GROUP BY an object, rather than a particular column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id(self, path: AP = None) -&gt; PK:
    &#34;&#34;&#34;Main use case: GROUP BY an object, rather than a particular column&#34;&#34;&#34;
    from dbgen.core.expr.pathattr import PathAttr

    return PK(PathAttr(path, AttrTup(self.id_str, self.name)))</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.id_fks"><code class="name flex">
<span>def <span class="ident">id_fks</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Names of all the identifying (top-level) FKs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_fks(self) -&gt; L[str]:
    &#34;&#34;&#34;Names of all the identifying (top-level) FKs &#34;&#34;&#34;
    return [f.name for f in self.fks if f.identifying]</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.ids"><code class="name flex">
<span>def <span class="ident">ids</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Names of all the identifying (top-level) attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ids(self) -&gt; L[str]:
    &#34;&#34;&#34;Names of all the identifying (top-level) attributes.&#34;&#34;&#34;
    return [a.name for a in self.attrs if a.identifying]</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.r"><code class="name flex">
<span>def <span class="ident">r</span></span>(<span>self, relname: str) ‑> <a title="dbgen.core.schema.RelTup" href="#dbgen.core.schema.RelTup">RelTup</a></span>
</code></dt>
<dd>
<div class="desc"><p>Refer to a relation of an object. Without a Model, we have to do with
reference by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def r(self, relname: str) -&gt; RelTup:
    &#34;&#34;&#34;
    Refer to a relation of an object. Without a Model, we have to do with
    reference by name
    &#34;&#34;&#34;
    return RelTup(self.name, relname)</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Obj.rename_attr"><code class="name flex">
<span>def <span class="ident">rename_attr</span></span>(<span>self, aname: str, newname: str) ‑> <a title="dbgen.core.schema.Obj" href="#dbgen.core.schema.Obj">Obj</a></span>
</code></dt>
<dd>
<div class="desc"><p>Copy of object with a renamed attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_attr(self, aname: str, newname: str) -&gt; &#34;Obj&#34;:
    &#34;&#34;&#34; Copy of object with a renamed attribute &#34;&#34;&#34;
    o = self.copy()
    newattr = o.attrdict[aname]
    o.attrs.remove(newattr)
    newattr.name = newname
    o.attrs.append(newattr)
    return o</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbgen.core.schema.Path"><code class="flex name class">
<span>class <span class="ident">Path</span></span>
<span>(</span><span>rels: List[<a title="dbgen.core.schema.RelTup" href="#dbgen.core.schema.RelTup">RelTup</a>] = None, attr: <a title="dbgen.core.schema.AttrTup" href="#dbgen.core.schema.AttrTup">AttrTup</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Some list of foreign keys (possibly empty), possibly followed by attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Path(Base):
    &#34;&#34;&#34;
    Some list of foreign keys (possibly empty), possibly followed by attribute
    &#34;&#34;&#34;

    def __init__(self, rels: L[RelTup] = None, attr: AttrTup = None) -&gt; None:
        self.rels = rels or []
        self.attr = attr
        assert rels or attr
        super().__init__()

    def __str__(self) -&gt; str:
        p = &#34;[%s]&#34; % &#34;,&#34;.join(map(str, self.rels)) if self.rels else &#34;&#34;
        comma = &#34;,&#34; if self.rels else &#34;&#34;
        a = comma + str(self.attr) if self.attr else &#34;&#34;
        return &#34;Path(%s%s)&#34; % (p, a)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(
            cls, rels=lists(RelTup._strat(), max_size=2), attr=AttrTup._strat()
        )

    def start(self) -&gt; str:
        &#34;&#34;&#34;Starting point of a path, always an object (name is returned)&#34;&#34;&#34;
        if self.rels:
            return self.rels[0].obj
        else:
            assert self.attr
            return self.attr.obj

    def select(self, m: &#34;Model&#34;) -&gt; str:
        &#34;&#34;&#34; Thing to select for when comparing path equality &#34;&#34;&#34;
        alias = self.start()
        for r in self.rels:
            alias += &#34;$&#34; + r.rel
        col = self._end_attr(m).name
        return &#39;&#34;%s&#34;.&#34;%s&#34;&#39; % (alias, col)

    def joins(self, ids: D[str, str], m: &#34;Model&#34;) -&gt; L[str]:
        &#34;&#34;&#34;From clause that makes self.select() defined in query&#34;&#34;&#34;

        j = []  # type: L[str]
        oldpath = self.start()
        jstr = &#39;JOIN &#34;{0}&#34; AS &#34;{1}&#34; ON &#34;{1}&#34;.&#34;{4}&#34; = &#34;{2}&#34;.&#34;{3}&#34;&#39;
        next = self.start()
        for i, r in enumerate(self.rels[:-1]):
            newpath = oldpath + &#34;$&#34; + r.rel
            next = self.rels[i + 1].obj
            nextid = ids[next]
            args = [next, newpath, oldpath, r.rel, nextid]
            j.append(jstr.format(*args))
            oldpath = newpath
        if self.rels:
            last = self.rels[-1].rel
            lastid = ids[m.get_rel(self.rels[-1]).o2]
            newpath = oldpath + &#34;$&#34; + last
            lastargs = [self._end_attr(m).obj, newpath, oldpath, last, lastid]
            j.append(jstr.format(*lastargs))
        return j

    def _end_attr(self, m: &#34;Model&#34;) -&gt; AttrTup:
        &#34;&#34;&#34;the ID colname if we don&#39;t have a normal attribute as terminus&#34;&#34;&#34;
        if not self.attr:
            rel = m.get_rel(self.rels[-1])
            return AttrTup(m[rel.o2].id_str, rel.o2)
        else:
            return self.attr

    def _path_end(self, m: &#34;Schema&#34;) -&gt; str:
        &#34;&#34;&#34;Determine the datatype of the end of a path.&#34;&#34;&#34;
        if (not self.attr) or (
            AttrTup(m[self.attr.obj].id_str, self.attr.obj) == self.attr
        ):
            return &#34;id&#34;
        else:
            o = m[self.attr.obj]
            a = [a for n, a in o.attrdict.items() if n == self.attr.name]
            assert len(a) &lt; 2
            if not a:
                err = &#34;Could not find %s in %s: Path %s&#34;
                import pdb

                pdb.set_trace()
                raise ValueError(err % (a, o, self))
            return str(a[0].dtype)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.schema.Path.joins"><code class="name flex">
<span>def <span class="ident">joins</span></span>(<span>self, ids: Dict[str, str], m: Model) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>From clause that makes self.select() defined in query</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def joins(self, ids: D[str, str], m: &#34;Model&#34;) -&gt; L[str]:
    &#34;&#34;&#34;From clause that makes self.select() defined in query&#34;&#34;&#34;

    j = []  # type: L[str]
    oldpath = self.start()
    jstr = &#39;JOIN &#34;{0}&#34; AS &#34;{1}&#34; ON &#34;{1}&#34;.&#34;{4}&#34; = &#34;{2}&#34;.&#34;{3}&#34;&#39;
    next = self.start()
    for i, r in enumerate(self.rels[:-1]):
        newpath = oldpath + &#34;$&#34; + r.rel
        next = self.rels[i + 1].obj
        nextid = ids[next]
        args = [next, newpath, oldpath, r.rel, nextid]
        j.append(jstr.format(*args))
        oldpath = newpath
    if self.rels:
        last = self.rels[-1].rel
        lastid = ids[m.get_rel(self.rels[-1]).o2]
        newpath = oldpath + &#34;$&#34; + last
        lastargs = [self._end_attr(m).obj, newpath, oldpath, last, lastid]
        j.append(jstr.format(*lastargs))
    return j</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Path.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, m: Model) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Thing to select for when comparing path equality</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, m: &#34;Model&#34;) -&gt; str:
    &#34;&#34;&#34; Thing to select for when comparing path equality &#34;&#34;&#34;
    alias = self.start()
    for r in self.rels:
        alias += &#34;$&#34; + r.rel
    col = self._end_attr(m).name
    return &#39;&#34;%s&#34;.&#34;%s&#34;&#39; % (alias, col)</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Path.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Starting point of a path, always an object (name is returned)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self) -&gt; str:
    &#34;&#34;&#34;Starting point of a path, always an object (name is returned)&#34;&#34;&#34;
    if self.rels:
        return self.rels[0].obj
    else:
        assert self.attr
        return self.attr.obj</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbgen.core.schema.PathEQ"><code class="flex name class">
<span>class <span class="ident">PathEQ</span></span>
<span>(</span><span>p1: <a title="dbgen.core.schema.Path" href="#dbgen.core.schema.Path">Path</a>, p2: <a title="dbgen.core.schema.Path" href="#dbgen.core.schema.Path">Path</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Specification that two paths should result in the same value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PathEQ(Base):
    &#34;&#34;&#34;Specification that two paths should result in the same value.&#34;&#34;&#34;

    def __init__(self, p1: Path, p2: Path) -&gt; None:
        assert p1 != p2, &#34;Cannot do pathEQ between things that are literally equivalent&#34;
        assert p1.start() == p2.start(), &#34;Paths must have same start point&#34;
        self.paths = set([p1, p2])
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;PathEQ({},{})&#34;.format(*self.paths)

    def __iter__(self) -&gt; Iter[Path]:
        return iter(self.paths)

    def __contains__(self, a: AttrTup) -&gt; bool:
        if isinstance(a, AttrTup):
            return any([a == p.attr for p in self.paths])
        else:
            raise TypeError(&#34;add to this to support more types of searching&#34;)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls, p1=Path._strat(), p2=Path._strat())

    def any(self) -&gt; Path:
        &#34;&#34;&#34;Gives one of the paths, doesn&#39;t matter which&#34;&#34;&#34;
        return next(iter(self))

    def start(self) -&gt; str:
        return self.any().start()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.schema.PathEQ.any"><code class="name flex">
<span>def <span class="ident">any</span></span>(<span>self) ‑> <a title="dbgen.core.schema.Path" href="#dbgen.core.schema.Path">Path</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gives one of the paths, doesn't matter which</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def any(self) -&gt; Path:
    &#34;&#34;&#34;Gives one of the paths, doesn&#39;t matter which&#34;&#34;&#34;
    return next(iter(self))</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.PathEQ.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self) -&gt; str:
    return self.any().start()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbgen.core.schema.QView"><code class="flex name class">
<span>class <span class="ident">QView</span></span>
<span>(</span><span>name: str, q: Query)</span>
</code></dt>
<dd>
<div class="desc"><p>Common methods shared by many DbGen objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QView(View):
    def __init__(self, name: str, q: &#34;Query&#34;) -&gt; None:
        self.name = name
        self.q = q

    def qstr(self) -&gt; str:
        return self.q.toJSON()

    def dep(self) -&gt; Dep:
        cd = [&#34;%s.%s&#34; % (a.obj, a.name) for a in self.q.allattr()]
        nc = [&#34;%s.%s&#34; % (self.name, x) for x in self.q.exprs]
        return Dep(self.q.allobj(), cd, [self.name], nc)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.core.schema.View" href="#dbgen.core.schema.View">View</a></li>
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.schema.QView.dep"><code class="name flex">
<span>def <span class="ident">dep</span></span>(<span>self) ‑> <a title="dbgen.core.misc.Dep" href="misc.html#dbgen.core.misc.Dep">Dep</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dep(self) -&gt; Dep:
    cd = [&#34;%s.%s&#34; % (a.obj, a.name) for a in self.q.allattr()]
    nc = [&#34;%s.%s&#34; % (self.name, x) for x in self.q.exprs]
    return Dep(self.q.allobj(), cd, [self.name], nc)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbgen.core.schema.View" href="#dbgen.core.schema.View">View</a></b></code>:
<ul class="hlist">
<li><code><a title="dbgen.core.schema.View.add" href="#dbgen.core.schema.View.add">add</a></code></li>
<li><code><a title="dbgen.core.schema.View.create" href="#dbgen.core.schema.View.create">create</a></code></li>
<li><code><a title="dbgen.core.schema.View.qstr" href="#dbgen.core.schema.View.qstr">qstr</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbgen.core.schema.RawView"><code class="flex name class">
<span>class <span class="ident">RawView</span></span>
<span>(</span><span>name: str, q: str, deps: List[str] = None, new: List[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Common methods shared by many DbGen objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawView(View):
    def __init__(
        self, name: str, q: str, deps: L[str] = None, new: L[str] = None
    ) -&gt; None:
        self.name = name
        self.raw = q
        self.deps = deps or []
        self.new = new or []

    def qstr(self) -&gt; str:
        return self.raw

    def dep(self) -&gt; Dep:
        td = [d for d in self.deps if &#34;.&#34; not in d]
        cd = [d for d in self.deps if &#34;.&#34; in d]
        nc = [&#34;%s.%s&#34; % (self.name, x) for x in self.new]
        return Dep(td, cd, [self.name], nc)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.core.schema.View" href="#dbgen.core.schema.View">View</a></li>
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.schema.RawView.dep"><code class="name flex">
<span>def <span class="ident">dep</span></span>(<span>self) ‑> <a title="dbgen.core.misc.Dep" href="misc.html#dbgen.core.misc.Dep">Dep</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dep(self) -&gt; Dep:
    td = [d for d in self.deps if &#34;.&#34; not in d]
    cd = [d for d in self.deps if &#34;.&#34; in d]
    nc = [&#34;%s.%s&#34; % (self.name, x) for x in self.new]
    return Dep(td, cd, [self.name], nc)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbgen.core.schema.View" href="#dbgen.core.schema.View">View</a></b></code>:
<ul class="hlist">
<li><code><a title="dbgen.core.schema.View.add" href="#dbgen.core.schema.View.add">add</a></code></li>
<li><code><a title="dbgen.core.schema.View.create" href="#dbgen.core.schema.View.create">create</a></code></li>
<li><code><a title="dbgen.core.schema.View.qstr" href="#dbgen.core.schema.View.qstr">qstr</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbgen.core.schema.Rel"><code class="flex name class">
<span>class <span class="ident">Rel</span></span>
<span>(</span><span>name: str, o1: str, o2: str = None, identifying: bool = False, desc: str = &#x27;&lt;No description&gt;&#x27;)</span>
</code></dt>
<dd>
<div class="desc"><p>Asymmetric Relation between objects</p>
<p>Can be identifying or non-identifying</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rel(Base):
    &#34;&#34;&#34;
    Asymmetric Relation between objects

    Can be identifying or non-identifying
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        o1: str,
        o2: str = None,
        identifying: bool = False,
        desc: str = &#34;&lt;No description&gt;&#34;,
    ) -&gt; None:
        self.name = name.lower()
        self.desc = desc
        self.o1 = o1.lower()
        self.o2 = o2.lower() if o2 else self.name
        self.identifying = identifying
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;Rel&lt;%s%s,%s -&gt; %s&gt;&#34; % (
            self.name,
            &#34;(id)&#34; if self.identifying else &#34;&#34;,
            self.o1,
            self.o2,
        )

    def __repr__(self) -&gt; str:
        return &#34;%s__%s&#34; % (self.o1, self.name)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls, o2=infer, identifying=infer, desc=infer)

    # Public methods #

    def print(self) -&gt; str:
        return &#34;%s.%s&#34; % (self.o1, self.name)

    def tup(self) -&gt; RelTup:
        &#34;&#34;&#34;Throw away info to make a RelTup&#34;&#34;&#34;
        return RelTup(self.o1, self.name)

    @property
    def default(self) -&gt; bool:
        &#34;&#34;&#34;Whether or not this Relation is the &#39;default&#39; one&#34;&#34;&#34;
        return self.name == self.o2

    @property
    def objs(self) -&gt; S[str]:
        return set([self.o1, self.o2])

    def other(self, obj: str) -&gt; str:
        &#34;&#34;&#34;
        Often we don&#39;t know which direction we are traversing on a FK
        We know which end we&#39;re coming from and simply want the other end
        &#34;&#34;&#34;
        assert obj in self.objs, &#34;%s not found in %s&#34; % (obj, self)

        out = [o for o in self.objs if o != obj]

        if out:
            return out[0]  # normal case
        else:
            return obj  # both to and from are the same table!</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="dbgen.core.schema.Rel.default"><code class="name">var <span class="ident">default</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether or not this Relation is the 'default' one</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default(self) -&gt; bool:
    &#34;&#34;&#34;Whether or not this Relation is the &#39;default&#39; one&#34;&#34;&#34;
    return self.name == self.o2</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Rel.objs"><code class="name">var <span class="ident">objs</span> : Set[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def objs(self) -&gt; S[str]:
    return set([self.o1, self.o2])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.schema.Rel.other"><code class="name flex">
<span>def <span class="ident">other</span></span>(<span>self, obj: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Often we don't know which direction we are traversing on a FK
We know which end we're coming from and simply want the other end</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def other(self, obj: str) -&gt; str:
    &#34;&#34;&#34;
    Often we don&#39;t know which direction we are traversing on a FK
    We know which end we&#39;re coming from and simply want the other end
    &#34;&#34;&#34;
    assert obj in self.objs, &#34;%s not found in %s&#34; % (obj, self)

    out = [o for o in self.objs if o != obj]

    if out:
        return out[0]  # normal case
    else:
        return obj  # both to and from are the same table!</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Rel.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self) -&gt; str:
    return &#34;%s.%s&#34; % (self.o1, self.name)</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.Rel.tup"><code class="name flex">
<span>def <span class="ident">tup</span></span>(<span>self) ‑> <a title="dbgen.core.schema.RelTup" href="#dbgen.core.schema.RelTup">RelTup</a></span>
</code></dt>
<dd>
<div class="desc"><p>Throw away info to make a RelTup</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tup(self) -&gt; RelTup:
    &#34;&#34;&#34;Throw away info to make a RelTup&#34;&#34;&#34;
    return RelTup(self.o1, self.name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbgen.core.schema.RelTup"><code class="flex name class">
<span>class <span class="ident">RelTup</span></span>
<span>(</span><span>obj: str, rel: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A tuple (objectname, relationname) that an object can produce independent
of a Model instance .... it will later have to be validated by the model to
be a relation that actually exists, but lower level classes can work with it
in the meantime</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelTup(Base):
    &#34;&#34;&#34;
    A tuple (objectname, relationname) that an object can produce independent
    of a Model instance .... it will later have to be validated by the model to
    be a relation that actually exists, but lower level classes can work with it
    in the meantime
    &#34;&#34;&#34;

    def __init__(self, obj: str, rel: str) -&gt; None:
        self.obj = obj.lower()
        self.rel = rel.lower()
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;Rel(%s,%s)&#34; % (self.obj, self.rel)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
</dd>
<dt id="dbgen.core.schema.SuperRel"><code class="flex name class">
<span>class <span class="ident">SuperRel</span></span>
<span>(</span><span>name: str, source: str, target: str, target_id_str: str, identifying: bool = False, desc: str = &#x27;&lt;No description&gt;&#x27;)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains information about source table name, relation name,
and target table ID column name.</p>
<p>Example:
SuperRel: Person.favorite_book &lt;-&gt; book.title
name: favorite_book
source: Person
book: target
target_id_str: Title</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SuperRel(Base):
    &#34;&#34;&#34;
    Contains information about source table name, relation name,
    and target table ID column name.

    Example:
    SuperRel: Person.favorite_book &lt;-&gt; book.title
        name: favorite_book
        source: Person
        book: target
        target_id_str: Title
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        source: str,
        target: str,
        target_id_str: str,
        identifying: bool = False,
        desc: str = &#34;&lt;No description&gt;&#34;,
    ) -&gt; None:
        self.name = name.lower()
        self.source = source.lower()
        self.target = target.lower()
        self.target_id_str = target_id_str
        self.identifying = identifying
        self.desc = desc

        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;SuperRel&lt;%s,%s -&gt; %s.%s&gt;&#34; % (
            self.name,
            self.source,
            self.target,
            self.target_id_str,
        )

    def __repr__(self) -&gt; str:
        return self.__str__()

    # Public methods #

    def print(self) -&gt; str:
        return &#34;%s.%s&#34; % (self.source, self.name)

    def tup(self) -&gt; RelTup:
        &#34;&#34;&#34;Throw away info to make a RelTup&#34;&#34;&#34;
        return RelTup(self.source, self.name)

    @property
    def default(self) -&gt; bool:
        &#34;&#34;&#34;Whether or not this Relation is the &#39;default&#39; one&#34;&#34;&#34;
        return self.name == self.target

    @property
    def objs(self) -&gt; S[str]:
        return set([self.source, self.target])

    def other(self, obj: str) -&gt; str:
        &#34;&#34;&#34;
        Often we don&#39;t know which direction we are traversing on a FK
        We know which end we&#39;re coming from and simply want the other end
        &#34;&#34;&#34;
        assert obj in self.objs, &#34;%s not found in %s&#34; % (obj, self)

        out = [o for o in self.objs if o != obj]

        if out:
            return out[0]  # normal case
        else:
            return obj  # both to and from are the same table!

    def to_rel(self) -&gt; Rel:
        return Rel(self.name, self.source, self.target, self.identifying, self.desc)

    # Private Methods #
    # ...
    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="dbgen.core.schema.SuperRel.default"><code class="name">var <span class="ident">default</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether or not this Relation is the 'default' one</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default(self) -&gt; bool:
    &#34;&#34;&#34;Whether or not this Relation is the &#39;default&#39; one&#34;&#34;&#34;
    return self.name == self.target</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.SuperRel.objs"><code class="name">var <span class="ident">objs</span> : Set[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def objs(self) -&gt; S[str]:
    return set([self.source, self.target])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.schema.SuperRel.other"><code class="name flex">
<span>def <span class="ident">other</span></span>(<span>self, obj: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Often we don't know which direction we are traversing on a FK
We know which end we're coming from and simply want the other end</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def other(self, obj: str) -&gt; str:
    &#34;&#34;&#34;
    Often we don&#39;t know which direction we are traversing on a FK
    We know which end we&#39;re coming from and simply want the other end
    &#34;&#34;&#34;
    assert obj in self.objs, &#34;%s not found in %s&#34; % (obj, self)

    out = [o for o in self.objs if o != obj]

    if out:
        return out[0]  # normal case
    else:
        return obj  # both to and from are the same table!</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.SuperRel.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self) -&gt; str:
    return &#34;%s.%s&#34; % (self.source, self.name)</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.SuperRel.to_rel"><code class="name flex">
<span>def <span class="ident">to_rel</span></span>(<span>self) ‑> <a title="dbgen.core.schema.Rel" href="#dbgen.core.schema.Rel">Rel</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_rel(self) -&gt; Rel:
    return Rel(self.name, self.source, self.target, self.identifying, self.desc)</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.SuperRel.tup"><code class="name flex">
<span>def <span class="ident">tup</span></span>(<span>self) ‑> <a title="dbgen.core.schema.RelTup" href="#dbgen.core.schema.RelTup">RelTup</a></span>
</code></dt>
<dd>
<div class="desc"><p>Throw away info to make a RelTup</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tup(self) -&gt; RelTup:
    &#34;&#34;&#34;Throw away info to make a RelTup&#34;&#34;&#34;
    return RelTup(self.source, self.name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbgen.core.schema.UserRel"><code class="flex name class">
<span>class <span class="ident">UserRel</span></span>
<span>(</span><span>name: str, tar: str = None, identifying: bool = False, desc: str = &#x27;&lt;No description&gt;&#x27;)</span>
</code></dt>
<dd>
<div class="desc"><p>USER EXPOSED Relation between objects. no need to specify source, as it is
declared from within the UserObj constructor.
Can be identifying or non-identifying</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserRel(Base):
    &#34;&#34;&#34;
    USER EXPOSED Relation between objects. no need to specify source, as it is
    declared from within the UserObj constructor.
    Can be identifying or non-identifying
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        tar: str = None,
        identifying: bool = False,
        desc: str = &#34;&lt;No description&gt;&#34;,
    ) -&gt; None:
        self.name = name.lower()
        self.desc = desc
        self.tar = tar.lower() if tar else self.name
        self.identifying = identifying
        super().__init__()

    def __str__(self) -&gt; str:
        idstr = &#34;(id)&#34; if self.identifying else &#34;&#34;
        return &#34;{}{} -&gt; {}&#34;.format(self.name, idstr, self.tar)

    def to_rel(self, obj: str) -&gt; &#34;Rel&#34;:
        return Rel(
            name=self.name,
            o1=obj,
            o2=self.tar,
            identifying=self.identifying,
            desc=self.desc,
        )

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.schema.UserRel.to_rel"><code class="name flex">
<span>def <span class="ident">to_rel</span></span>(<span>self, obj: str) ‑> <a title="dbgen.core.schema.Rel" href="#dbgen.core.schema.Rel">Rel</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_rel(self, obj: str) -&gt; &#34;Rel&#34;:
    return Rel(
        name=self.name,
        o1=obj,
        o2=self.tar,
        identifying=self.identifying,
        desc=self.desc,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbgen.core.schema.View"><code class="flex name class">
<span>class <span class="ident">View</span></span>
</code></dt>
<dd>
<div class="desc"><p>Common methods shared by many DbGen objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class View(Base, metaclass=ABCMeta):
    def __str__(self) -&gt; str:
        return &#34;View(%s)&#34; % (self.name)

    name = &#34;&#34;

    @abstractmethod
    def dep(self) -&gt; Dep:
        raise NotImplementedError

    @abstractmethod
    def qstr(self) -&gt; str:
        &#34;&#34;&#34;String representing the query (either JSON or raw SQL)&#34;&#34;&#34;
        raise NotImplementedError

    def add(self, cxn: Conn) -&gt; int:
        &#34;&#34;&#34;add view to metadb, return PK&#34;&#34;&#34;
        # Try to find an Object with an equivalent hash in the existing table
        get_v = mkSelectCmd(&#34;view&#34;, [&#34;view_id&#34;], [&#34;view_id&#34;])
        v_id = sqlselect(cxn, get_v, [self.hash])

        if v_id:
            return v_id[0][0]  # already there
        else:
            # Create a new record in the View table and get its ID
            cmd = mkInsCmd(&#34;view&#34;, [&#34;view_id&#34;, &#34;name&#34;, &#34;query&#34;])
            sqlexecute(cxn, cmd, [self.hash, self.name, self.qstr()])
            return sqlselect(cxn, get_v, [self.hash])[0][0]

    @classmethod
    @abstractmethod
    def _strat(cls) -&gt; SearchStrategy:
        raise NotImplementedError

    def create(self) -&gt; str:
        &#34;&#34;&#34;
        Generate SQL necessary to create an object&#39;s corresponding table
        &#34;&#34;&#34;
        return &#34;CREATE VIEW {} AS {}&#34;.format(self.name, self.qstr())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dbgen.core.schema.QView" href="#dbgen.core.schema.QView">QView</a></li>
<li><a title="dbgen.core.schema.RawView" href="#dbgen.core.schema.RawView">RawView</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dbgen.core.schema.View.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.schema.View.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, cxn: Any) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>add view to metadb, return PK</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, cxn: Conn) -&gt; int:
    &#34;&#34;&#34;add view to metadb, return PK&#34;&#34;&#34;
    # Try to find an Object with an equivalent hash in the existing table
    get_v = mkSelectCmd(&#34;view&#34;, [&#34;view_id&#34;], [&#34;view_id&#34;])
    v_id = sqlselect(cxn, get_v, [self.hash])

    if v_id:
        return v_id[0][0]  # already there
    else:
        # Create a new record in the View table and get its ID
        cmd = mkInsCmd(&#34;view&#34;, [&#34;view_id&#34;, &#34;name&#34;, &#34;query&#34;])
        sqlexecute(cxn, cmd, [self.hash, self.name, self.qstr()])
        return sqlselect(cxn, get_v, [self.hash])[0][0]</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.View.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate SQL necessary to create an object's corresponding table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self) -&gt; str:
    &#34;&#34;&#34;
    Generate SQL necessary to create an object&#39;s corresponding table
    &#34;&#34;&#34;
    return &#34;CREATE VIEW {} AS {}&#34;.format(self.name, self.qstr())</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.View.dep"><code class="name flex">
<span>def <span class="ident">dep</span></span>(<span>self) ‑> <a title="dbgen.core.misc.Dep" href="misc.html#dbgen.core.misc.Dep">Dep</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def dep(self) -&gt; Dep:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="dbgen.core.schema.View.qstr"><code class="name flex">
<span>def <span class="ident">qstr</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representing the query (either JSON or raw SQL)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def qstr(self) -&gt; str:
    &#34;&#34;&#34;String representing the query (either JSON or raw SQL)&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dbgen.core" href="index.html">dbgen.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dbgen.core.schema.Attr" href="#dbgen.core.schema.Attr">Attr</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.schema.Attr.create_col" href="#dbgen.core.schema.Attr.create_col">create_col</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.schema.AttrTup" href="#dbgen.core.schema.AttrTup">AttrTup</a></code></h4>
</li>
<li>
<h4><code><a title="dbgen.core.schema.Obj" href="#dbgen.core.schema.Obj">Obj</a></code></h4>
<ul class="two-column">
<li><code><a title="dbgen.core.schema.Obj.act" href="#dbgen.core.schema.Obj.act">act</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.add" href="#dbgen.core.schema.Obj.add">add</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.add_attrs" href="#dbgen.core.schema.Obj.add_attrs">add_attrs</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.attrdict" href="#dbgen.core.schema.Obj.attrdict">attrdict</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.attrnames" href="#dbgen.core.schema.Obj.attrnames">attrnames</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.create" href="#dbgen.core.schema.Obj.create">create</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.default_action" href="#dbgen.core.schema.Obj.default_action">default_action</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.del_attrs" href="#dbgen.core.schema.Obj.del_attrs">del_attrs</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.fkdict" href="#dbgen.core.schema.Obj.fkdict">fkdict</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.get" href="#dbgen.core.schema.Obj.get">get</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.id" href="#dbgen.core.schema.Obj.id">id</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.id_fks" href="#dbgen.core.schema.Obj.id_fks">id_fks</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.ids" href="#dbgen.core.schema.Obj.ids">ids</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.r" href="#dbgen.core.schema.Obj.r">r</a></code></li>
<li><code><a title="dbgen.core.schema.Obj.rename_attr" href="#dbgen.core.schema.Obj.rename_attr">rename_attr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.schema.Path" href="#dbgen.core.schema.Path">Path</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.schema.Path.joins" href="#dbgen.core.schema.Path.joins">joins</a></code></li>
<li><code><a title="dbgen.core.schema.Path.select" href="#dbgen.core.schema.Path.select">select</a></code></li>
<li><code><a title="dbgen.core.schema.Path.start" href="#dbgen.core.schema.Path.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.schema.PathEQ" href="#dbgen.core.schema.PathEQ">PathEQ</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.schema.PathEQ.any" href="#dbgen.core.schema.PathEQ.any">any</a></code></li>
<li><code><a title="dbgen.core.schema.PathEQ.start" href="#dbgen.core.schema.PathEQ.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.schema.QView" href="#dbgen.core.schema.QView">QView</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.schema.QView.dep" href="#dbgen.core.schema.QView.dep">dep</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.schema.RawView" href="#dbgen.core.schema.RawView">RawView</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.schema.RawView.dep" href="#dbgen.core.schema.RawView.dep">dep</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.schema.Rel" href="#dbgen.core.schema.Rel">Rel</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.schema.Rel.default" href="#dbgen.core.schema.Rel.default">default</a></code></li>
<li><code><a title="dbgen.core.schema.Rel.objs" href="#dbgen.core.schema.Rel.objs">objs</a></code></li>
<li><code><a title="dbgen.core.schema.Rel.other" href="#dbgen.core.schema.Rel.other">other</a></code></li>
<li><code><a title="dbgen.core.schema.Rel.print" href="#dbgen.core.schema.Rel.print">print</a></code></li>
<li><code><a title="dbgen.core.schema.Rel.tup" href="#dbgen.core.schema.Rel.tup">tup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.schema.RelTup" href="#dbgen.core.schema.RelTup">RelTup</a></code></h4>
</li>
<li>
<h4><code><a title="dbgen.core.schema.SuperRel" href="#dbgen.core.schema.SuperRel">SuperRel</a></code></h4>
<ul class="two-column">
<li><code><a title="dbgen.core.schema.SuperRel.default" href="#dbgen.core.schema.SuperRel.default">default</a></code></li>
<li><code><a title="dbgen.core.schema.SuperRel.objs" href="#dbgen.core.schema.SuperRel.objs">objs</a></code></li>
<li><code><a title="dbgen.core.schema.SuperRel.other" href="#dbgen.core.schema.SuperRel.other">other</a></code></li>
<li><code><a title="dbgen.core.schema.SuperRel.print" href="#dbgen.core.schema.SuperRel.print">print</a></code></li>
<li><code><a title="dbgen.core.schema.SuperRel.to_rel" href="#dbgen.core.schema.SuperRel.to_rel">to_rel</a></code></li>
<li><code><a title="dbgen.core.schema.SuperRel.tup" href="#dbgen.core.schema.SuperRel.tup">tup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.schema.UserRel" href="#dbgen.core.schema.UserRel">UserRel</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.schema.UserRel.to_rel" href="#dbgen.core.schema.UserRel.to_rel">to_rel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.schema.View" href="#dbgen.core.schema.View">View</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.schema.View.add" href="#dbgen.core.schema.View.add">add</a></code></li>
<li><code><a title="dbgen.core.schema.View.create" href="#dbgen.core.schema.View.create">create</a></code></li>
<li><code><a title="dbgen.core.schema.View.dep" href="#dbgen.core.schema.View.dep">dep</a></code></li>
<li><code><a title="dbgen.core.schema.View.name" href="#dbgen.core.schema.View.name">name</a></code></li>
<li><code><a title="dbgen.core.schema.View.qstr" href="#dbgen.core.schema.View.qstr">qstr</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>