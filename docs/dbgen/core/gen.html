<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>dbgen.core.gen API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dbgen.core.gen</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import defaultdict
from typing import TYPE_CHECKING, Any
from typing import Dict as D
from typing import List as L
from typing import Optional as Opt
from typing import Set as S
from typing import Tuple as T

from hypothesis.strategies import SearchStrategy, builds, lists
from networkx import DiGraph

from dbgen.core.action import Action
from dbgen.core.func import Env, Func, defaultEnv
from dbgen.core.funclike import Arg, PyBlock
from dbgen.core.misc import Dep
from dbgen.core.query import Query
from dbgen.core.schema import Obj
from dbgen.templates import jinja_env
from dbgen.utils.graphs import topsort_with_dict
from dbgen.utils.lists import concat_map
from dbgen.utils.misc import Base, nonempty
from dbgen.utils.sql import Connection as Conn
from dbgen.utils.sql import (
    DictCursor,
    mkInsCmd,
    mkSelectCmd,
    mkUpdateCmd,
    sqlexecute,
    sqlselect,
)
from dbgen.utils.str_utils import hash_

# Internal
if TYPE_CHECKING:
    from dbgen.core.model.model import Model

    Model
&#34;&#34;&#34;
Defines a Generator, as well as a Model method that is directly related
&#34;&#34;&#34;
################################################################################


class Gen(Base):
    &#34;&#34;&#34;Generator: populates database with data&#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        desc: str = None,
        query: Query = None,
        funcs: L[PyBlock] = None,
        actions: L[Action] = None,
        tags: L[str] = None,
        env: Env = None,
        batch_size: int = None,
    ) -&gt; None:

        # assert actions, &#39;Cannot have generator which does nothing&#39;
        assert name
        self.name = name.lower()
        self.desc = desc or &#34;&lt;no description&gt;&#34;
        self.query = query
        self.funcs = self._order_funcs(funcs or [], query)
        self.actions = actions or []
        self.tags = [t.lower() for t in tags or []]
        self.env = env or defaultEnv
        self.batch_size = batch_size
        for func in self.funcs:
            self.env += func.func.env
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;Gen&lt;%s&gt;&#34; % self.name

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        &#34;&#34;&#34;A hypothesis strategy for generating random examples.&#34;&#34;&#34;
        return builds(
            cls,
            name=nonempty,
            desc=nonempty,
            query=Query._strat(),
            funcs=lists(PyBlock._strat(), max_size=2),
            actions=lists(Action._strat(), min_size=1, max_size=2),
            tags=lists(nonempty, max_size=3),
        )

    ##################
    # Public Methods #
    ##################

    def update_status(
        self, conn: Conn, run_id: int, status: str, err: str = &#34;&#34;
    ) -&gt; None:
        &#34;&#34;&#34;Update this gens status in the meta-database, also set error if provided&#34;&#34;&#34;
        cols = [&#34;status&#34;, &#34;error&#34;] if err else [&#34;status&#34;]
        binds = [status, err, run_id, self.name] if err else [status, run_id, self.name]
        q = mkUpdateCmd(&#34;gens&#34;, cols, [&#34;run&#34;, &#34;name&#34;])
        sqlexecute(conn, q, binds)

    def get_id(self, c: Conn) -&gt; L[tuple]:  # THIS IS OBSOLETE BC HASH IS ID?
        &#34;&#34;&#34; Assuming we&#39;ve inserted already &#34;&#34;&#34;
        check = self.hash
        get_a = mkSelectCmd(&#34;gen&#34;, [&#34;gen_id&#34;], [&#34;gen_id&#34;])
        return sqlselect(c, get_a, [check])

    def hasher(self, x: Any) -&gt; str:
        &#34;&#34;&#34;Unique hash function to this Generator&#34;&#34;&#34;
        return hash_(str(self.hash) + str(x))

    def dep(self, universe: D[str, Obj]) -&gt; Dep:
        &#34;&#34;&#34;
        Determine the tabs/cols that are both inputs and outputs to the Gen

        Args:
            universe (D[str, Obj])

        Returns:
            Dep
        &#34;&#34;&#34;
        # Analyze allattr and allobj to get query dependencies
        if self.query:
            tabdeps = self.query.allobj()
            coldeps = [&#34;%s.%s&#34; % (a.obj, a.name) for a in self.query.allattr()]
            for r in self.query.allrels():
                coldeps.append(r.obj + &#34;.&#34; + r.rel)
        else:
            tabdeps, coldeps = [], []

        # Analyze actions to see what new cols and tabs are yielded
        newtabs, newcols = [], []  # type: T[L[str],L[str]]

        for a in self.actions:
            tabdeps.extend(a.tabdeps())
            newtabs.extend(a.newtabs())
            newcols.extend(a.newcols(universe))

        # Allow for unethical hacks
        for t in self.tags:
            if t[:4] == &#34;dep &#34;:
                coldeps.append(t[4:])

        return Dep(tabdeps, coldeps, newtabs, newcols)

    def add(self, cxn: &#34;Conn&#34;) -&gt; int:
        &#34;&#34;&#34;
        Add the Generator to the metaDB which stores info about a model (if
        it&#39;s not already in there) and return the ID
        &#34;&#34;&#34;
        a_id = self.get_id(cxn)
        if a_id:
            return a_id[0][0]
        else:
            cmd = mkInsCmd(&#34;gen&#34;, [&#34;gen_id&#34;, &#34;name&#34;, &#34;description&#34;, &#34;gen_json&#34;])
            sqlexecute(cxn, cmd, [self.hash, self.name, self.desc, self.toJSON()])
            aid = self.get_id(cxn)
            return aid[0][0]

    def rename_object(self, o: Obj, n: str) -&gt; &#34;Gen&#34;:
        &#34;&#34;&#34;Change all references to an object to account for name change&#34;&#34;&#34;
        g = self.copy()
        if g.query:
            g.query.basis = [n if b == o.name else b for b in g.query.basis]
        for i, a in enumerate(g.actions):
            g.actions[i] = a.rename_object(o, n)
        return g

    def purge(self, conn: Conn, mconn: Conn, universe: D[str, Obj]) -&gt; None:
        &#34;&#34;&#34;
        If a generator is purged, then any
        tables it populates will be truncated. Any columns it populates will be set all
        to NULL
        &#34;&#34;&#34;
        d = self.dep(universe)
        tabs, cols = d.tabs_yielded, d.cols_yielded
        for t in tabs:
            sqlexecute(conn, &#34;TRUNCATE {} CASCADE&#34;.format(t))

        for t, c in map(lambda x: x.split(&#34;.&#34;), cols):
            sqlexecute(mconn, &#34;UPDATE {} SET {} = NULL&#34;.format(t, c))

        gids = sqlselect(mconn, &#34;SELECT gen_id FROM gen WHERE name = %s&#34;, [self.name])
        for gid in gids:
            sqlexecute(mconn, &#34;DELETE FROM repeats WHERE gen_id = %s&#34;, [gid])

    def test(
        self,
        objs,
        input_rows: L[D[str, Any]],
        rename_dict: bool = True,
        verbose: bool = False,
    ) -&gt; T[L[dict], L[D[str, L[D[str, Any]]]]]:
        # Apply the
        output_dicts = []
        for row in input_rows:
            result_dict = {self.query.hash: row} if self.query else {}
            if verbose:
                from tqdm import tqdm

                with tqdm(total=len(self.funcs)) as tq:
                    for pb in self.funcs:
                        tq.set_description(pb.func.name)
                        result_dict[pb.hash] = pb(result_dict)
                        tq.update()
            else:
                for pb in self.funcs:
                    result_dict[pb.hash] = pb(result_dict)

            # Replace pyblock hashes with function names if flag is True
            lambda_count = 0
            func_name_dict = {}
            name_count: D[str, int] = defaultdict(int)
            for pb in self.funcs:
                name = pb.func.name
                if pb.func.is_lam:
                    func_name_dict[pb.hash] = f&#34;lambda{lambda_count}-&gt;{pb.outnames}&#34;
                    lambda_count += 1
                else:
                    # Need to account for multiple pyblocks using same function
                    if name_count[name] &gt; 0:
                        func_name_dict[pb.hash] = &#34;_&#34;.join(
                            [name, str(name_count[name])]
                        )
                    else:
                        func_name_dict[pb.hash] = name
                    name_count[name] += 1

            output_dicts.append(result_dict)

        action_dicts: D[str, list] = defaultdict(list)
        for i, a in enumerate(self.actions):
            output_dict = a.test(objs=objs, rows=output_dicts)
            for table_name, rows in output_dict.items():
                action_dicts[table_name].extend(rows)

        # Rename PyBlocks
        if rename_dict:
            for i, row in enumerate(output_dicts):
                output_dicts[i] = {
                    func_name_dict.get(key, &#34;query&#34;): val for key, val in row.items()
                }

        return output_dicts, [action_dicts]

    def test_with_db(
        self,
        objs,
        db: Conn = None,
        limit: int = 5,
        rename_dict: bool = True,
        interact: bool = False,
        input_rows: L[dict] = [],
    ) -&gt; T[L[D[str, dict]], L[D[str, L[dict]]]]:
        assert limit &lt;= 200, &#34;Don&#39;t allow for more than 200 rows with test with db&#34;
        assert (
            db is None or self.query is not None
        ), &#34;Need to provide a db connection if generator has a query&#34;

        if db is not None and self.query is not None:
            cursor = db.connect(auto_commit=False).cursor(
                f&#34;test-{self.name}&#34;, cursor_factory=DictCursor
            )
            # If there is a query get the row count and execute it
            query_str = self.query.showQ(limit=limit)
            print(&#34;Executing Query...&#34;)
            cursor.execute(query_str)
            input_rows.extend(cursor.fetchall())
            print(&#34;Fetching Rows...&#34;)
            print(&#34;Closing Connection...&#34;)
            cursor.close()

        if interact:
            from dbgen.utils.interact import interact_gen

            return interact_gen(objs, self, input_rows)
        else:
            return self.test(objs, input_rows, rename_dict)

    ##################
    # Private Methods #
    ##################

    def _constargs(self) -&gt; L[Func]:
        return concat_map(lambda y: y._constargs(), self.funcs)

    @staticmethod
    def _order_funcs(pbs: L[PyBlock], q: Opt[Query]) -&gt; L[PyBlock]:
        &#34;&#34;&#34;Make dependency graph among PyBlocks and determine execution order&#34;&#34;&#34;
        G = DiGraph()
        d = {pb.hash: pb for pb in pbs}
        G.add_nodes_from(d.keys())
        for pb in pbs:
            for arg_ind, a in enumerate(pb.args):
                if isinstance(a, Arg) and (not q or a.key != q.hash):
                    if a.key not in d:
                        raise KeyError(
                            f&#34;Argument {arg_ind} of {pb.func.name} refers to an object with a hash key {a.key} asking for name \&#34;{getattr(a,&#39;name&#39;,&#39;&lt;No Name&gt;&#39;)}\&#34; that does not exist in the namespace.&#34;
                            &#34;Did you make sure to include all PyBlocks in the func kwarg of Gen()?&#34;
                        )
                    assert a.key in d, pb.func.name
                    G.add_edge(a.key, pb.hash)
        return topsort_with_dict(G, d)

    def _get_all_saved_key_dict(self) -&gt; D[str, S[str]]:
        saved_keys = {}  # type: D[str,S[str]]
        for act in self.actions:
            for hash_loc, name_set in self._get_saved_key_dict(act).items():
                saved_keys.update(
                    {hash_loc: set([*name_set, *saved_keys.get(hash_loc, set())])}
                )

        return saved_keys

    def _get_saved_key_dict(self, action: Action) -&gt; D[str, S[str]]:
        saved_keys = {}  # type: D[str,S[str]]
        if action.pk:
            if isinstance(action.pk, Arg):
                hash_loc = action.pk.key
                arg_name = action.pk.name
                saved_keys.update(
                    {hash_loc: set([arg_name, *saved_keys.get(hash_loc, set())])}
                )

        for val in action.attrs.values():
            if isinstance(val, Arg):
                saved_keys.update(
                    {val.key: set([val.name, *saved_keys.get(val.key, set())])}
                )

        for fk_action in action.fks.values():
            for hash_loc, name_set in self._get_saved_key_dict(fk_action).items():
                saved_keys.update(
                    {hash_loc: set([*name_set, *saved_keys.get(hash_loc, set())])}
                )

        return saved_keys

    # ######################
    # # Airflow Operator Exports
    # # --------------------
    def operator(self, model_name: str, run: int, universe: D[str, Obj]) -&gt; str:

        # Get the necessary template
        gen_template = jinja_env.get_template(&#34;generator.py.jinja&#34;)

        # Prepare the rendered arguments
        pbs = [
            (&#34;pb&#34; + str(pb.hash).replace(&#34;-&#34;, &#34;neg&#34;), pb.hash, pb.make_src())
            for pb in self.funcs
        ]
        loaders = [loader.make_src() for loader in self.actions]
        objs = {
            oname: (o.id_str, repr(o.ids()), repr(o.id_fks()))
            for oname, o in universe.items()
        }
        constfuncs = [cf.src for cf in self._constargs()]

        # Set the template arguements
        template_kwargs = dict(
            name=self.name,
            pyblocks=pbs,
            genname=self.name,
            env=str(self.env) if self.env else &#34;&#34;,
            loads=loaders,
            objs=objs,
            query=self.query.showQ() if self.query else False,
            queryhash=self.query.hash if self.query else None,
            run=run,
            model_name=model_name,
            constfuncs=constfuncs,
        )

        return gen_template.render(**template_kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dbgen.core.gen.Gen"><code class="flex name class">
<span>class <span class="ident">Gen</span></span>
<span>(</span><span>name: str, desc: str = None, query: <a title="dbgen.core.query.Query" href="query.html#dbgen.core.query.Query">Query</a> = None, funcs: List[<a title="dbgen.core.funclike.PyBlock" href="funclike.html#dbgen.core.funclike.PyBlock">PyBlock</a>] = None, actions: List[<a title="dbgen.core.action.Action" href="action.html#dbgen.core.action.Action">Action</a>] = None, tags: List[str] = None, env: <a title="dbgen.core.func.Env" href="func.html#dbgen.core.func.Env">Env</a> = None, batch_size: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generator: populates database with data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gen(Base):
    &#34;&#34;&#34;Generator: populates database with data&#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        desc: str = None,
        query: Query = None,
        funcs: L[PyBlock] = None,
        actions: L[Action] = None,
        tags: L[str] = None,
        env: Env = None,
        batch_size: int = None,
    ) -&gt; None:

        # assert actions, &#39;Cannot have generator which does nothing&#39;
        assert name
        self.name = name.lower()
        self.desc = desc or &#34;&lt;no description&gt;&#34;
        self.query = query
        self.funcs = self._order_funcs(funcs or [], query)
        self.actions = actions or []
        self.tags = [t.lower() for t in tags or []]
        self.env = env or defaultEnv
        self.batch_size = batch_size
        for func in self.funcs:
            self.env += func.func.env
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;Gen&lt;%s&gt;&#34; % self.name

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        &#34;&#34;&#34;A hypothesis strategy for generating random examples.&#34;&#34;&#34;
        return builds(
            cls,
            name=nonempty,
            desc=nonempty,
            query=Query._strat(),
            funcs=lists(PyBlock._strat(), max_size=2),
            actions=lists(Action._strat(), min_size=1, max_size=2),
            tags=lists(nonempty, max_size=3),
        )

    ##################
    # Public Methods #
    ##################

    def update_status(
        self, conn: Conn, run_id: int, status: str, err: str = &#34;&#34;
    ) -&gt; None:
        &#34;&#34;&#34;Update this gens status in the meta-database, also set error if provided&#34;&#34;&#34;
        cols = [&#34;status&#34;, &#34;error&#34;] if err else [&#34;status&#34;]
        binds = [status, err, run_id, self.name] if err else [status, run_id, self.name]
        q = mkUpdateCmd(&#34;gens&#34;, cols, [&#34;run&#34;, &#34;name&#34;])
        sqlexecute(conn, q, binds)

    def get_id(self, c: Conn) -&gt; L[tuple]:  # THIS IS OBSOLETE BC HASH IS ID?
        &#34;&#34;&#34; Assuming we&#39;ve inserted already &#34;&#34;&#34;
        check = self.hash
        get_a = mkSelectCmd(&#34;gen&#34;, [&#34;gen_id&#34;], [&#34;gen_id&#34;])
        return sqlselect(c, get_a, [check])

    def hasher(self, x: Any) -&gt; str:
        &#34;&#34;&#34;Unique hash function to this Generator&#34;&#34;&#34;
        return hash_(str(self.hash) + str(x))

    def dep(self, universe: D[str, Obj]) -&gt; Dep:
        &#34;&#34;&#34;
        Determine the tabs/cols that are both inputs and outputs to the Gen

        Args:
            universe (D[str, Obj])

        Returns:
            Dep
        &#34;&#34;&#34;
        # Analyze allattr and allobj to get query dependencies
        if self.query:
            tabdeps = self.query.allobj()
            coldeps = [&#34;%s.%s&#34; % (a.obj, a.name) for a in self.query.allattr()]
            for r in self.query.allrels():
                coldeps.append(r.obj + &#34;.&#34; + r.rel)
        else:
            tabdeps, coldeps = [], []

        # Analyze actions to see what new cols and tabs are yielded
        newtabs, newcols = [], []  # type: T[L[str],L[str]]

        for a in self.actions:
            tabdeps.extend(a.tabdeps())
            newtabs.extend(a.newtabs())
            newcols.extend(a.newcols(universe))

        # Allow for unethical hacks
        for t in self.tags:
            if t[:4] == &#34;dep &#34;:
                coldeps.append(t[4:])

        return Dep(tabdeps, coldeps, newtabs, newcols)

    def add(self, cxn: &#34;Conn&#34;) -&gt; int:
        &#34;&#34;&#34;
        Add the Generator to the metaDB which stores info about a model (if
        it&#39;s not already in there) and return the ID
        &#34;&#34;&#34;
        a_id = self.get_id(cxn)
        if a_id:
            return a_id[0][0]
        else:
            cmd = mkInsCmd(&#34;gen&#34;, [&#34;gen_id&#34;, &#34;name&#34;, &#34;description&#34;, &#34;gen_json&#34;])
            sqlexecute(cxn, cmd, [self.hash, self.name, self.desc, self.toJSON()])
            aid = self.get_id(cxn)
            return aid[0][0]

    def rename_object(self, o: Obj, n: str) -&gt; &#34;Gen&#34;:
        &#34;&#34;&#34;Change all references to an object to account for name change&#34;&#34;&#34;
        g = self.copy()
        if g.query:
            g.query.basis = [n if b == o.name else b for b in g.query.basis]
        for i, a in enumerate(g.actions):
            g.actions[i] = a.rename_object(o, n)
        return g

    def purge(self, conn: Conn, mconn: Conn, universe: D[str, Obj]) -&gt; None:
        &#34;&#34;&#34;
        If a generator is purged, then any
        tables it populates will be truncated. Any columns it populates will be set all
        to NULL
        &#34;&#34;&#34;
        d = self.dep(universe)
        tabs, cols = d.tabs_yielded, d.cols_yielded
        for t in tabs:
            sqlexecute(conn, &#34;TRUNCATE {} CASCADE&#34;.format(t))

        for t, c in map(lambda x: x.split(&#34;.&#34;), cols):
            sqlexecute(mconn, &#34;UPDATE {} SET {} = NULL&#34;.format(t, c))

        gids = sqlselect(mconn, &#34;SELECT gen_id FROM gen WHERE name = %s&#34;, [self.name])
        for gid in gids:
            sqlexecute(mconn, &#34;DELETE FROM repeats WHERE gen_id = %s&#34;, [gid])

    def test(
        self,
        objs,
        input_rows: L[D[str, Any]],
        rename_dict: bool = True,
        verbose: bool = False,
    ) -&gt; T[L[dict], L[D[str, L[D[str, Any]]]]]:
        # Apply the
        output_dicts = []
        for row in input_rows:
            result_dict = {self.query.hash: row} if self.query else {}
            if verbose:
                from tqdm import tqdm

                with tqdm(total=len(self.funcs)) as tq:
                    for pb in self.funcs:
                        tq.set_description(pb.func.name)
                        result_dict[pb.hash] = pb(result_dict)
                        tq.update()
            else:
                for pb in self.funcs:
                    result_dict[pb.hash] = pb(result_dict)

            # Replace pyblock hashes with function names if flag is True
            lambda_count = 0
            func_name_dict = {}
            name_count: D[str, int] = defaultdict(int)
            for pb in self.funcs:
                name = pb.func.name
                if pb.func.is_lam:
                    func_name_dict[pb.hash] = f&#34;lambda{lambda_count}-&gt;{pb.outnames}&#34;
                    lambda_count += 1
                else:
                    # Need to account for multiple pyblocks using same function
                    if name_count[name] &gt; 0:
                        func_name_dict[pb.hash] = &#34;_&#34;.join(
                            [name, str(name_count[name])]
                        )
                    else:
                        func_name_dict[pb.hash] = name
                    name_count[name] += 1

            output_dicts.append(result_dict)

        action_dicts: D[str, list] = defaultdict(list)
        for i, a in enumerate(self.actions):
            output_dict = a.test(objs=objs, rows=output_dicts)
            for table_name, rows in output_dict.items():
                action_dicts[table_name].extend(rows)

        # Rename PyBlocks
        if rename_dict:
            for i, row in enumerate(output_dicts):
                output_dicts[i] = {
                    func_name_dict.get(key, &#34;query&#34;): val for key, val in row.items()
                }

        return output_dicts, [action_dicts]

    def test_with_db(
        self,
        objs,
        db: Conn = None,
        limit: int = 5,
        rename_dict: bool = True,
        interact: bool = False,
        input_rows: L[dict] = [],
    ) -&gt; T[L[D[str, dict]], L[D[str, L[dict]]]]:
        assert limit &lt;= 200, &#34;Don&#39;t allow for more than 200 rows with test with db&#34;
        assert (
            db is None or self.query is not None
        ), &#34;Need to provide a db connection if generator has a query&#34;

        if db is not None and self.query is not None:
            cursor = db.connect(auto_commit=False).cursor(
                f&#34;test-{self.name}&#34;, cursor_factory=DictCursor
            )
            # If there is a query get the row count and execute it
            query_str = self.query.showQ(limit=limit)
            print(&#34;Executing Query...&#34;)
            cursor.execute(query_str)
            input_rows.extend(cursor.fetchall())
            print(&#34;Fetching Rows...&#34;)
            print(&#34;Closing Connection...&#34;)
            cursor.close()

        if interact:
            from dbgen.utils.interact import interact_gen

            return interact_gen(objs, self, input_rows)
        else:
            return self.test(objs, input_rows, rename_dict)

    ##################
    # Private Methods #
    ##################

    def _constargs(self) -&gt; L[Func]:
        return concat_map(lambda y: y._constargs(), self.funcs)

    @staticmethod
    def _order_funcs(pbs: L[PyBlock], q: Opt[Query]) -&gt; L[PyBlock]:
        &#34;&#34;&#34;Make dependency graph among PyBlocks and determine execution order&#34;&#34;&#34;
        G = DiGraph()
        d = {pb.hash: pb for pb in pbs}
        G.add_nodes_from(d.keys())
        for pb in pbs:
            for arg_ind, a in enumerate(pb.args):
                if isinstance(a, Arg) and (not q or a.key != q.hash):
                    if a.key not in d:
                        raise KeyError(
                            f&#34;Argument {arg_ind} of {pb.func.name} refers to an object with a hash key {a.key} asking for name \&#34;{getattr(a,&#39;name&#39;,&#39;&lt;No Name&gt;&#39;)}\&#34; that does not exist in the namespace.&#34;
                            &#34;Did you make sure to include all PyBlocks in the func kwarg of Gen()?&#34;
                        )
                    assert a.key in d, pb.func.name
                    G.add_edge(a.key, pb.hash)
        return topsort_with_dict(G, d)

    def _get_all_saved_key_dict(self) -&gt; D[str, S[str]]:
        saved_keys = {}  # type: D[str,S[str]]
        for act in self.actions:
            for hash_loc, name_set in self._get_saved_key_dict(act).items():
                saved_keys.update(
                    {hash_loc: set([*name_set, *saved_keys.get(hash_loc, set())])}
                )

        return saved_keys

    def _get_saved_key_dict(self, action: Action) -&gt; D[str, S[str]]:
        saved_keys = {}  # type: D[str,S[str]]
        if action.pk:
            if isinstance(action.pk, Arg):
                hash_loc = action.pk.key
                arg_name = action.pk.name
                saved_keys.update(
                    {hash_loc: set([arg_name, *saved_keys.get(hash_loc, set())])}
                )

        for val in action.attrs.values():
            if isinstance(val, Arg):
                saved_keys.update(
                    {val.key: set([val.name, *saved_keys.get(val.key, set())])}
                )

        for fk_action in action.fks.values():
            for hash_loc, name_set in self._get_saved_key_dict(fk_action).items():
                saved_keys.update(
                    {hash_loc: set([*name_set, *saved_keys.get(hash_loc, set())])}
                )

        return saved_keys

    # ######################
    # # Airflow Operator Exports
    # # --------------------
    def operator(self, model_name: str, run: int, universe: D[str, Obj]) -&gt; str:

        # Get the necessary template
        gen_template = jinja_env.get_template(&#34;generator.py.jinja&#34;)

        # Prepare the rendered arguments
        pbs = [
            (&#34;pb&#34; + str(pb.hash).replace(&#34;-&#34;, &#34;neg&#34;), pb.hash, pb.make_src())
            for pb in self.funcs
        ]
        loaders = [loader.make_src() for loader in self.actions]
        objs = {
            oname: (o.id_str, repr(o.ids()), repr(o.id_fks()))
            for oname, o in universe.items()
        }
        constfuncs = [cf.src for cf in self._constargs()]

        # Set the template arguements
        template_kwargs = dict(
            name=self.name,
            pyblocks=pbs,
            genname=self.name,
            env=str(self.env) if self.env else &#34;&#34;,
            loads=loaders,
            objs=objs,
            query=self.query.showQ() if self.query else False,
            queryhash=self.query.hash if self.query else None,
            run=run,
            model_name=model_name,
            constfuncs=constfuncs,
        )

        return gen_template.render(**template_kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.gen.Gen.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, cxn: Conn) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Add the Generator to the metaDB which stores info about a model (if
it's not already in there) and return the ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, cxn: &#34;Conn&#34;) -&gt; int:
    &#34;&#34;&#34;
    Add the Generator to the metaDB which stores info about a model (if
    it&#39;s not already in there) and return the ID
    &#34;&#34;&#34;
    a_id = self.get_id(cxn)
    if a_id:
        return a_id[0][0]
    else:
        cmd = mkInsCmd(&#34;gen&#34;, [&#34;gen_id&#34;, &#34;name&#34;, &#34;description&#34;, &#34;gen_json&#34;])
        sqlexecute(cxn, cmd, [self.hash, self.name, self.desc, self.toJSON()])
        aid = self.get_id(cxn)
        return aid[0][0]</code></pre>
</details>
</dd>
<dt id="dbgen.core.gen.Gen.dep"><code class="name flex">
<span>def <span class="ident">dep</span></span>(<span>self, universe: Dict[str, <a title="dbgen.core.schema.Obj" href="schema.html#dbgen.core.schema.Obj">Obj</a>]) ‑> <a title="dbgen.core.misc.Dep" href="misc.html#dbgen.core.misc.Dep">Dep</a></span>
</code></dt>
<dd>
<div class="desc"><p>Determine the tabs/cols that are both inputs and outputs to the Gen</p>
<h2 id="args">Args</h2>
<p>universe (D[str, Obj])</p>
<h2 id="returns">Returns</h2>
<p>Dep</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dep(self, universe: D[str, Obj]) -&gt; Dep:
    &#34;&#34;&#34;
    Determine the tabs/cols that are both inputs and outputs to the Gen

    Args:
        universe (D[str, Obj])

    Returns:
        Dep
    &#34;&#34;&#34;
    # Analyze allattr and allobj to get query dependencies
    if self.query:
        tabdeps = self.query.allobj()
        coldeps = [&#34;%s.%s&#34; % (a.obj, a.name) for a in self.query.allattr()]
        for r in self.query.allrels():
            coldeps.append(r.obj + &#34;.&#34; + r.rel)
    else:
        tabdeps, coldeps = [], []

    # Analyze actions to see what new cols and tabs are yielded
    newtabs, newcols = [], []  # type: T[L[str],L[str]]

    for a in self.actions:
        tabdeps.extend(a.tabdeps())
        newtabs.extend(a.newtabs())
        newcols.extend(a.newcols(universe))

    # Allow for unethical hacks
    for t in self.tags:
        if t[:4] == &#34;dep &#34;:
            coldeps.append(t[4:])

    return Dep(tabdeps, coldeps, newtabs, newcols)</code></pre>
</details>
</dd>
<dt id="dbgen.core.gen.Gen.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self, c: Any) ‑> List[tuple]</span>
</code></dt>
<dd>
<div class="desc"><p>Assuming we've inserted already</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id(self, c: Conn) -&gt; L[tuple]:  # THIS IS OBSOLETE BC HASH IS ID?
    &#34;&#34;&#34; Assuming we&#39;ve inserted already &#34;&#34;&#34;
    check = self.hash
    get_a = mkSelectCmd(&#34;gen&#34;, [&#34;gen_id&#34;], [&#34;gen_id&#34;])
    return sqlselect(c, get_a, [check])</code></pre>
</details>
</dd>
<dt id="dbgen.core.gen.Gen.hasher"><code class="name flex">
<span>def <span class="ident">hasher</span></span>(<span>self, x: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Unique hash function to this Generator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasher(self, x: Any) -&gt; str:
    &#34;&#34;&#34;Unique hash function to this Generator&#34;&#34;&#34;
    return hash_(str(self.hash) + str(x))</code></pre>
</details>
</dd>
<dt id="dbgen.core.gen.Gen.operator"><code class="name flex">
<span>def <span class="ident">operator</span></span>(<span>self, model_name: str, run: int, universe: Dict[str, <a title="dbgen.core.schema.Obj" href="schema.html#dbgen.core.schema.Obj">Obj</a>]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def operator(self, model_name: str, run: int, universe: D[str, Obj]) -&gt; str:

    # Get the necessary template
    gen_template = jinja_env.get_template(&#34;generator.py.jinja&#34;)

    # Prepare the rendered arguments
    pbs = [
        (&#34;pb&#34; + str(pb.hash).replace(&#34;-&#34;, &#34;neg&#34;), pb.hash, pb.make_src())
        for pb in self.funcs
    ]
    loaders = [loader.make_src() for loader in self.actions]
    objs = {
        oname: (o.id_str, repr(o.ids()), repr(o.id_fks()))
        for oname, o in universe.items()
    }
    constfuncs = [cf.src for cf in self._constargs()]

    # Set the template arguements
    template_kwargs = dict(
        name=self.name,
        pyblocks=pbs,
        genname=self.name,
        env=str(self.env) if self.env else &#34;&#34;,
        loads=loaders,
        objs=objs,
        query=self.query.showQ() if self.query else False,
        queryhash=self.query.hash if self.query else None,
        run=run,
        model_name=model_name,
        constfuncs=constfuncs,
    )

    return gen_template.render(**template_kwargs)</code></pre>
</details>
</dd>
<dt id="dbgen.core.gen.Gen.purge"><code class="name flex">
<span>def <span class="ident">purge</span></span>(<span>self, conn: Any, mconn: Any, universe: Dict[str, <a title="dbgen.core.schema.Obj" href="schema.html#dbgen.core.schema.Obj">Obj</a>]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>If a generator is purged, then any
tables it populates will be truncated. Any columns it populates will be set all
to NULL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purge(self, conn: Conn, mconn: Conn, universe: D[str, Obj]) -&gt; None:
    &#34;&#34;&#34;
    If a generator is purged, then any
    tables it populates will be truncated. Any columns it populates will be set all
    to NULL
    &#34;&#34;&#34;
    d = self.dep(universe)
    tabs, cols = d.tabs_yielded, d.cols_yielded
    for t in tabs:
        sqlexecute(conn, &#34;TRUNCATE {} CASCADE&#34;.format(t))

    for t, c in map(lambda x: x.split(&#34;.&#34;), cols):
        sqlexecute(mconn, &#34;UPDATE {} SET {} = NULL&#34;.format(t, c))

    gids = sqlselect(mconn, &#34;SELECT gen_id FROM gen WHERE name = %s&#34;, [self.name])
    for gid in gids:
        sqlexecute(mconn, &#34;DELETE FROM repeats WHERE gen_id = %s&#34;, [gid])</code></pre>
</details>
</dd>
<dt id="dbgen.core.gen.Gen.rename_object"><code class="name flex">
<span>def <span class="ident">rename_object</span></span>(<span>self, o: <a title="dbgen.core.schema.Obj" href="schema.html#dbgen.core.schema.Obj">Obj</a>, n: str) ‑> <a title="dbgen.core.gen.Gen" href="#dbgen.core.gen.Gen">Gen</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change all references to an object to account for name change</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_object(self, o: Obj, n: str) -&gt; &#34;Gen&#34;:
    &#34;&#34;&#34;Change all references to an object to account for name change&#34;&#34;&#34;
    g = self.copy()
    if g.query:
        g.query.basis = [n if b == o.name else b for b in g.query.basis]
    for i, a in enumerate(g.actions):
        g.actions[i] = a.rename_object(o, n)
    return g</code></pre>
</details>
</dd>
<dt id="dbgen.core.gen.Gen.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>self, objs, input_rows: List[Dict[str, Any]], rename_dict: bool = True, verbose: bool = False) ‑> Tuple[List[dict], List[Dict[str, List[Dict[str, Any]]]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test(
    self,
    objs,
    input_rows: L[D[str, Any]],
    rename_dict: bool = True,
    verbose: bool = False,
) -&gt; T[L[dict], L[D[str, L[D[str, Any]]]]]:
    # Apply the
    output_dicts = []
    for row in input_rows:
        result_dict = {self.query.hash: row} if self.query else {}
        if verbose:
            from tqdm import tqdm

            with tqdm(total=len(self.funcs)) as tq:
                for pb in self.funcs:
                    tq.set_description(pb.func.name)
                    result_dict[pb.hash] = pb(result_dict)
                    tq.update()
        else:
            for pb in self.funcs:
                result_dict[pb.hash] = pb(result_dict)

        # Replace pyblock hashes with function names if flag is True
        lambda_count = 0
        func_name_dict = {}
        name_count: D[str, int] = defaultdict(int)
        for pb in self.funcs:
            name = pb.func.name
            if pb.func.is_lam:
                func_name_dict[pb.hash] = f&#34;lambda{lambda_count}-&gt;{pb.outnames}&#34;
                lambda_count += 1
            else:
                # Need to account for multiple pyblocks using same function
                if name_count[name] &gt; 0:
                    func_name_dict[pb.hash] = &#34;_&#34;.join(
                        [name, str(name_count[name])]
                    )
                else:
                    func_name_dict[pb.hash] = name
                name_count[name] += 1

        output_dicts.append(result_dict)

    action_dicts: D[str, list] = defaultdict(list)
    for i, a in enumerate(self.actions):
        output_dict = a.test(objs=objs, rows=output_dicts)
        for table_name, rows in output_dict.items():
            action_dicts[table_name].extend(rows)

    # Rename PyBlocks
    if rename_dict:
        for i, row in enumerate(output_dicts):
            output_dicts[i] = {
                func_name_dict.get(key, &#34;query&#34;): val for key, val in row.items()
            }

    return output_dicts, [action_dicts]</code></pre>
</details>
</dd>
<dt id="dbgen.core.gen.Gen.test_with_db"><code class="name flex">
<span>def <span class="ident">test_with_db</span></span>(<span>self, objs, db: Any = None, limit: int = 5, rename_dict: bool = True, interact: bool = False, input_rows: List[dict] = []) ‑> Tuple[List[Dict[str, dict]], List[Dict[str, List[dict]]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_with_db(
    self,
    objs,
    db: Conn = None,
    limit: int = 5,
    rename_dict: bool = True,
    interact: bool = False,
    input_rows: L[dict] = [],
) -&gt; T[L[D[str, dict]], L[D[str, L[dict]]]]:
    assert limit &lt;= 200, &#34;Don&#39;t allow for more than 200 rows with test with db&#34;
    assert (
        db is None or self.query is not None
    ), &#34;Need to provide a db connection if generator has a query&#34;

    if db is not None and self.query is not None:
        cursor = db.connect(auto_commit=False).cursor(
            f&#34;test-{self.name}&#34;, cursor_factory=DictCursor
        )
        # If there is a query get the row count and execute it
        query_str = self.query.showQ(limit=limit)
        print(&#34;Executing Query...&#34;)
        cursor.execute(query_str)
        input_rows.extend(cursor.fetchall())
        print(&#34;Fetching Rows...&#34;)
        print(&#34;Closing Connection...&#34;)
        cursor.close()

    if interact:
        from dbgen.utils.interact import interact_gen

        return interact_gen(objs, self, input_rows)
    else:
        return self.test(objs, input_rows, rename_dict)</code></pre>
</details>
</dd>
<dt id="dbgen.core.gen.Gen.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, conn: Any, run_id: int, status: str, err: str = '') ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update this gens status in the meta-database, also set error if provided</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_status(
    self, conn: Conn, run_id: int, status: str, err: str = &#34;&#34;
) -&gt; None:
    &#34;&#34;&#34;Update this gens status in the meta-database, also set error if provided&#34;&#34;&#34;
    cols = [&#34;status&#34;, &#34;error&#34;] if err else [&#34;status&#34;]
    binds = [status, err, run_id, self.name] if err else [status, run_id, self.name]
    q = mkUpdateCmd(&#34;gens&#34;, cols, [&#34;run&#34;, &#34;name&#34;])
    sqlexecute(conn, q, binds)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dbgen.core" href="index.html">dbgen.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dbgen.core.gen.Gen" href="#dbgen.core.gen.Gen">Gen</a></code></h4>
<ul class="two-column">
<li><code><a title="dbgen.core.gen.Gen.add" href="#dbgen.core.gen.Gen.add">add</a></code></li>
<li><code><a title="dbgen.core.gen.Gen.dep" href="#dbgen.core.gen.Gen.dep">dep</a></code></li>
<li><code><a title="dbgen.core.gen.Gen.get_id" href="#dbgen.core.gen.Gen.get_id">get_id</a></code></li>
<li><code><a title="dbgen.core.gen.Gen.hasher" href="#dbgen.core.gen.Gen.hasher">hasher</a></code></li>
<li><code><a title="dbgen.core.gen.Gen.operator" href="#dbgen.core.gen.Gen.operator">operator</a></code></li>
<li><code><a title="dbgen.core.gen.Gen.purge" href="#dbgen.core.gen.Gen.purge">purge</a></code></li>
<li><code><a title="dbgen.core.gen.Gen.rename_object" href="#dbgen.core.gen.Gen.rename_object">rename_object</a></code></li>
<li><code><a title="dbgen.core.gen.Gen.test" href="#dbgen.core.gen.Gen.test">test</a></code></li>
<li><code><a title="dbgen.core.gen.Gen.test_with_db" href="#dbgen.core.gen.Gen.test_with_db">test_with_db</a></code></li>
<li><code><a title="dbgen.core.gen.Gen.update_status" href="#dbgen.core.gen.Gen.update_status">update_status</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>