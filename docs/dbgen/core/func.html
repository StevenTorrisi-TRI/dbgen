<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>dbgen.core.func API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dbgen.core.func</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># External Modules
from typing import Any, List as L, Dict as D, Union as U, Callable as C
from os import environ
from re import findall
from os.path import join, exists
from sys import version_info
from inspect import (
    getdoc,
    signature,
    getsourcefile,
    getsourcelines,
    getmembers,
    isfunction,
)
from importlib.util import spec_from_file_location, module_from_spec
from hypothesis.strategies import SearchStrategy, builds

# Iternal Modules
from dbgen.core.datatypes import DataType, Tuple
from dbgen.utils.exceptions import DBgenInternalError
from dbgen.utils.misc import hash_, Base
from dbgen.utils.sql import (
    sqlexecute,
    mkInsCmd,
    sqlselect,
    mkSelectCmd,
    Connection as Conn,
)
from ..utils.config import DBGEN_TMP, DEFAULT_ENV

&#34;&#34;&#34;
Defines the Func class, which is initialized with any Python callable but gets
enriched in the __init__ with a lot more information and methods (from inspect)
&#34;&#34;&#34;
assert version_info[1] &gt; 5, &#34;Stop using old python3 (need 3.x, x &gt; 5)&#34;
################################################################################
class Import(Base):
    &#34;&#34;&#34;
    Representation of an Python import line.

    Examples:

    --&gt; from libname import unaliased, things, aliased as Thing
        Import(&#39;libname&#39;,         &lt;---- (DO NOT make this a keyword argument!!!)
                &#39;unaliased&#39;,
                &#39;things&#39;,
                aliased = &#39;Thing&#39;)

    --&gt; import numpy as np
        Import(&#39;numpy&#39;, alias = &#39;np&#39;)

    Unsupported edge case: trying to import some variable literally named
                            &#34;alias&#34; using an alias
    &#34;&#34;&#34;

    def __init__(
        self,
        lib: str,
        unaliased_imports: U[L[str], str] = None,
        lib_alias: str = &#34;&#34;,
        aliased_imports: D[str, str] = None,
    ) -&gt; None:

        err = &#34;Can&#39;t import %s as %s AND import specific terms (%s,%s) at once&#34;
        terms = unaliased_imports or aliased_imports
        assert not (lib_alias and terms), err % (
            lib,
            lib_alias,
            unaliased_imports,
            aliased_imports,
        )

        self.lib = lib
        self.lib_alias = lib_alias

        if isinstance(unaliased_imports, str):
            self.unaliased_imports = [unaliased_imports]
        else:
            self.unaliased_imports = unaliased_imports or []
        self.aliased_imports = aliased_imports or {}
        super().__init__()

    def __str__(self) -&gt; str:
        if not (self.unaliased_imports or self.aliased_imports):
            alias = (&#34; as %s&#34; % self.lib_alias) if self.lib_alias else &#34;&#34;
            return &#34;import %s %s&#34; % (self.lib, alias)
        else:
            als = [&#34;%s as %s&#34; % (k, v) for k, v in self.aliased_imports.items()]
            terms = list(self.unaliased_imports) + als
            return &#34;from %s import %s&#34; % (self.lib, &#34;, &#34;.join(terms))

    def __eq__(self, other: object) -&gt; bool:
        return False if not isinstance(other, Import) else vars(self) == vars(other)

    def __hash__(self) -&gt; int:
        return int(self.hash)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)

    @staticmethod
    def from_str(s: str) -&gt; &#34;Import&#34;:
        &#34;&#34;&#34;Parse a header line (parens not supported yet)&#34;&#34;&#34;
        if s[:6] == &#34;import&#34;:
            if &#34; as &#34; in s[7:]:
                lib, lib_alias = [s[7:].split(&#34;as&#34;)[i].strip() for i in range(2)]
                return Import(lib, lib_alias=lib_alias)
            return Import(s.split()[1].strip())
        else:
            i = s.find(&#34;import&#34;)
            a, lib = s[:i].split()
            assert a == &#34;from&#34;, &#34;Bad source code beginning : \n\n\n&#34; + s
            pat = r&#34;([a-zA-Z0-9\_]+\s*(?:as\s*[a-zA-Z0-9\_]+)?)&#34;
            groups = findall(pat, s[i + 6 :])
            objs = [list(map(str.strip, g.split(&#34;as&#34;))) for g in groups]
            # objs_ = [x[0] if len(x) == 1 else tuple(x) for x in objs]
            unalias = [x[0] for x in objs if len(x) == 1]
            aliased = {x[0]: x[1] for x in objs if len(x) == 2}

            return Import(lib, unaliased_imports=unalias, aliased_imports=aliased)


class Env(Base):
    &#34;&#34;&#34;
    Environment in which a python statement gets executed
    &#34;&#34;&#34;

    def __init__(self, imports: L[Import] = None) -&gt; None:

        if imports:
            assert isinstance(
                imports, list
            ), &#34;Env takes in a list of imports. If there is 1 import wrap it in a list&#34;
        self.imports = imports or []
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;\n&#34;.join(map(str, self.imports))

    def __add__(self, other: &#34;Env&#34;) -&gt; &#34;Env&#34;:
        return Env(list(set(self.imports + other.imports)))

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)

    # Public methods #

    @staticmethod
    def from_str(strs: L[str]) -&gt; &#34;Env&#34;:
        &#34;&#34;&#34;Parse a header&#34;&#34;&#34;
        return Env([Import.from_str(s) for s in strs])

    @classmethod
    def from_file(cls, pth: str) -&gt; &#34;Env&#34;:
        with open(pth, &#34;r&#34;) as f:
            return cls.from_str(f.readlines())


emptyEnv = Env()
# Default environement is read from file if environmental variable is set
# otherwise no default is used
defaultEnv = (
    Env.from_file(DEFAULT_ENV) if DEFAULT_ENV and exists(DEFAULT_ENV) else emptyEnv
)


################################################################################
class Func(Base):
    &#34;&#34;&#34;
    A function that can be used during the DB generation process.
    &#34;&#34;&#34;

    def __init__(self, src: str, env: Env = None) -&gt; None:
        assert isinstance(src, str), &#34;Expected src str, but got %s&#34; % type(src)

        self.src = src

        if env:
            assert isinstance(env, Env), &#34;Expected Env, but got %s&#34; % type(env)
            self.env = env
        else:
            self.env = Env.from_file(environ[&#34;DEFAULT_ENV&#34;])
        super().__init__()

    def __str__(self) -&gt; str:
        n = self.src.count(&#34;\n&#34;)
        s = &#34;&#34; if n == 1 else &#34;s&#34;
        return &#34;&lt;Func (%d line%s)&gt;&#34; % (n, s)

    def __call__(self, *args: Any) -&gt; Any:
        if hasattr(self, &#34;_func&#34;):
            return self._func(*args)
        else:
            f = self._from_src()
            return f(*args)

    def __repr__(self) -&gt; str:
        return self.name

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)

    # Properties #

    @property
    def name(self) -&gt; str:
        return self._from_src().__name__

    @property
    def is_lam(self) -&gt; bool:
        return self.src[:6] == &#34;lambda&#34;

    @property
    def doc(self) -&gt; str:
        return getdoc(self._from_src()) or &#34;&#34;

    @property
    def sig(self) -&gt; Any:
        return signature(self._from_src())

    @property
    def argnames(self) -&gt; L[str]:
        return list(self.sig.parameters)

    @property
    def nIn(self) -&gt; int:
        return len(self.inTypes)

    @property
    def notImp(self) -&gt; bool:
        return &#34;NotImplementedError&#34; in self.src

    @property
    def output(self) -&gt; Any:
        return self.sig.return_annotation

    @property
    def nOut(self) -&gt; int:
        return len(self.outTypes)

    @property
    def inTypes(self) -&gt; L[DataType]:
        return [
            DataType.get_datatype(x.annotation) for x in self.sig.parameters.values()
        ]

    @property
    def outTypes(self) -&gt; L[DataType]:
        ot = DataType.get_datatype(self.output)
        if len(ot) == 1:
            return [ot]
        else:
            assert isinstance(ot, Tuple)
            return ot.args

    def file(self) -&gt; str:
        lam = &#34;f = &#34; if self.is_lam else &#34;&#34;
        return str(self.env) + &#34;\n&#34; + lam + self.src

    # Private methods #

    def _from_src(self) -&gt; C:
        &#34;&#34;&#34;
        Execute source code to get a callable
        &#34;&#34;&#34;

        pth = join(DBGEN_TMP, str(hash_(self.file())) + &#34;.py&#34;)

        if not exists(pth):
            with open(pth, &#34;w&#34;) as t:
                t.write(self.file())

        f = self.path_to_func(pth)

        return f

    # Public methods #
    def store_func(self) -&gt; None:
        &#34;&#34;&#34;Load func from source code and store as attribute (better performance
        but object is no longer serializable / comparable for equality )
        &#34;&#34;&#34;
        self._func = self._from_src()

    def del_func(self) -&gt; None:
        &#34;&#34;&#34;Remove callable attribute after performance is no longer needed&#34;&#34;&#34;
        if hasattr(self, &#34;_func&#34;):
            del self._func

    def add(self, cxn: Conn) -&gt; int:
        &#34;&#34;&#34;
        Log function data to metaDB, return its ID
        &#34;&#34;&#34;
        q = mkSelectCmd(&#34;_func&#34;, [&#34;func_id&#34;], [&#34;checksum&#34;])
        f_id = sqlselect(cxn, q, [hash_(self.src)])
        if f_id:
            return f_id[0][0]
        else:

            cols = [
                &#34;name&#34;,
                &#34;checksum&#34;,
                &#34;source&#34;,
                &#34;docstring&#34;,
                &#34;inTypes&#34;,
                &#34;outType&#34;,
                &#34;n_in&#34;,
                &#34;n_out&#34;,
            ]

            binds = [
                self.name,
                hash_(self.src),
                self.src,
                self.doc,
                str(self.inTypes),
                str(self.outTypes),
                self.nIn,
                self.nOut,
            ]

            sqlexecute(cxn, mkInsCmd(&#34;_func&#34;, cols), binds)
            f_id = sqlselect(cxn, q, [hash_(self.src)])
            return f_id[0][0]

    @staticmethod
    def path_to_func(pth: str) -&gt; C:

        try:
            spec = spec_from_file_location(&#34;random&#34;, pth)
            mod = module_from_spec(spec)
            assert spec and spec.loader, &#34;Spec or Spec.loader are broken&#34;
            spec.loader.exec_module(mod)  # type: ignore
            funcs = [
                o
                for o in getmembers(mod)
                if isfunction(o[1]) and getsourcefile(o[1]) == pth
            ]
            assert len(funcs) == 1, &#34;Bad input file %s has %d functions, not 1&#34; % (
                pth,
                len(funcs),
            )
            return funcs[0][1]

        except Exception as e:
            if exists(pth):
                with open(pth) as f:
                    content = f.read()
            raise DBgenInternalError(
                f&#34;Error while trying to load source code. You may be missing an import in your PyBlocks Env object. \nPath:{pth}\nFile Contents:\n--------\n{content}\n--------\nLoad Error: {e}&#34;
            )

    @classmethod
    def from_callable(cls, f: U[C, &#34;Func&#34;], env: Env = None) -&gt; &#34;Func&#34;:
        &#34;&#34;&#34;
        Generate a func from a variety of possible input data types.
        &#34;&#34;&#34;
        if isinstance(f, Func):
            # assert not getattr(env,&#39;imports&#39;,False)
            return f
        else:
            assert callable(f), &#34;tried to instantiate Func, but not callable %s&#34; % (
                type(f)
            )
            return Func(src=cls.get_source(f), env=env)

    @staticmethod
    def get_source(f: C) -&gt; str:
        &#34;&#34;&#34;
        Return the source code, even if it&#39;s lambda function.
        &#34;&#34;&#34;
        try:
            source_lines, _ = getsourcelines(f)
        except (IOError, TypeError,) as e:
            # functions defined in pdb / REPL / eval / some other way in which source code not clear
            import pdb

            pdb.set_trace()
            raise ValueError(&#34;from_callable: &#34;, f, e)

        # Handle &#39;def&#39;-ed functions and long lambdas
        src = &#34;&#34;.join(source_lines).strip()

        if len(source_lines) &gt; 1 and src[:3] == &#34;def&#34;:
            return src

        err = &#39;Only one &#34;lambda&#34; allowed per line: &#39;
        assert src.count(&#34;lambda&#34;) == 1, err + src

        src_ = src[src.find(&#34;lambda&#34;) :]  # start of lambda function

        # Slice off trailing chars until we get a callable function
        while len(src_) &gt; 6:
            try:
                if callable(eval(src_)):
                    return src_
            except (SyntaxError, NameError):
                pass

            src_ = src_[:-1].strip()

        raise ValueError(&#34;could not parse lambda: &#34; + src)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dbgen.core.func.Env"><code class="flex name class">
<span>class <span class="ident">Env</span></span>
<span>(</span><span>imports: List[<a title="dbgen.core.func.Import" href="#dbgen.core.func.Import">Import</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Environment in which a python statement gets executed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Env(Base):
    &#34;&#34;&#34;
    Environment in which a python statement gets executed
    &#34;&#34;&#34;

    def __init__(self, imports: L[Import] = None) -&gt; None:

        if imports:
            assert isinstance(
                imports, list
            ), &#34;Env takes in a list of imports. If there is 1 import wrap it in a list&#34;
        self.imports = imports or []
        super().__init__()

    def __str__(self) -&gt; str:
        return &#34;\n&#34;.join(map(str, self.imports))

    def __add__(self, other: &#34;Env&#34;) -&gt; &#34;Env&#34;:
        return Env(list(set(self.imports + other.imports)))

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)

    # Public methods #

    @staticmethod
    def from_str(strs: L[str]) -&gt; &#34;Env&#34;:
        &#34;&#34;&#34;Parse a header&#34;&#34;&#34;
        return Env([Import.from_str(s) for s in strs])

    @classmethod
    def from_file(cls, pth: str) -&gt; &#34;Env&#34;:
        with open(pth, &#34;r&#34;) as f:
            return cls.from_str(f.readlines())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="dbgen.core.func.Env.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>pth: str) ‑> <a title="dbgen.core.func.Env" href="#dbgen.core.func.Env">Env</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(cls, pth: str) -&gt; &#34;Env&#34;:
    with open(pth, &#34;r&#34;) as f:
        return cls.from_str(f.readlines())</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Env.from_str"><code class="name flex">
<span>def <span class="ident">from_str</span></span>(<span>strs: List[str]) ‑> <a title="dbgen.core.func.Env" href="#dbgen.core.func.Env">Env</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_str(strs: L[str]) -&gt; &#34;Env&#34;:
    &#34;&#34;&#34;Parse a header&#34;&#34;&#34;
    return Env([Import.from_str(s) for s in strs])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbgen.core.func.Func"><code class="flex name class">
<span>class <span class="ident">Func</span></span>
<span>(</span><span>src: str, env: <a title="dbgen.core.func.Env" href="#dbgen.core.func.Env">Env</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that can be used during the DB generation process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Func(Base):
    &#34;&#34;&#34;
    A function that can be used during the DB generation process.
    &#34;&#34;&#34;

    def __init__(self, src: str, env: Env = None) -&gt; None:
        assert isinstance(src, str), &#34;Expected src str, but got %s&#34; % type(src)

        self.src = src

        if env:
            assert isinstance(env, Env), &#34;Expected Env, but got %s&#34; % type(env)
            self.env = env
        else:
            self.env = Env.from_file(environ[&#34;DEFAULT_ENV&#34;])
        super().__init__()

    def __str__(self) -&gt; str:
        n = self.src.count(&#34;\n&#34;)
        s = &#34;&#34; if n == 1 else &#34;s&#34;
        return &#34;&lt;Func (%d line%s)&gt;&#34; % (n, s)

    def __call__(self, *args: Any) -&gt; Any:
        if hasattr(self, &#34;_func&#34;):
            return self._func(*args)
        else:
            f = self._from_src()
            return f(*args)

    def __repr__(self) -&gt; str:
        return self.name

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)

    # Properties #

    @property
    def name(self) -&gt; str:
        return self._from_src().__name__

    @property
    def is_lam(self) -&gt; bool:
        return self.src[:6] == &#34;lambda&#34;

    @property
    def doc(self) -&gt; str:
        return getdoc(self._from_src()) or &#34;&#34;

    @property
    def sig(self) -&gt; Any:
        return signature(self._from_src())

    @property
    def argnames(self) -&gt; L[str]:
        return list(self.sig.parameters)

    @property
    def nIn(self) -&gt; int:
        return len(self.inTypes)

    @property
    def notImp(self) -&gt; bool:
        return &#34;NotImplementedError&#34; in self.src

    @property
    def output(self) -&gt; Any:
        return self.sig.return_annotation

    @property
    def nOut(self) -&gt; int:
        return len(self.outTypes)

    @property
    def inTypes(self) -&gt; L[DataType]:
        return [
            DataType.get_datatype(x.annotation) for x in self.sig.parameters.values()
        ]

    @property
    def outTypes(self) -&gt; L[DataType]:
        ot = DataType.get_datatype(self.output)
        if len(ot) == 1:
            return [ot]
        else:
            assert isinstance(ot, Tuple)
            return ot.args

    def file(self) -&gt; str:
        lam = &#34;f = &#34; if self.is_lam else &#34;&#34;
        return str(self.env) + &#34;\n&#34; + lam + self.src

    # Private methods #

    def _from_src(self) -&gt; C:
        &#34;&#34;&#34;
        Execute source code to get a callable
        &#34;&#34;&#34;

        pth = join(DBGEN_TMP, str(hash_(self.file())) + &#34;.py&#34;)

        if not exists(pth):
            with open(pth, &#34;w&#34;) as t:
                t.write(self.file())

        f = self.path_to_func(pth)

        return f

    # Public methods #
    def store_func(self) -&gt; None:
        &#34;&#34;&#34;Load func from source code and store as attribute (better performance
        but object is no longer serializable / comparable for equality )
        &#34;&#34;&#34;
        self._func = self._from_src()

    def del_func(self) -&gt; None:
        &#34;&#34;&#34;Remove callable attribute after performance is no longer needed&#34;&#34;&#34;
        if hasattr(self, &#34;_func&#34;):
            del self._func

    def add(self, cxn: Conn) -&gt; int:
        &#34;&#34;&#34;
        Log function data to metaDB, return its ID
        &#34;&#34;&#34;
        q = mkSelectCmd(&#34;_func&#34;, [&#34;func_id&#34;], [&#34;checksum&#34;])
        f_id = sqlselect(cxn, q, [hash_(self.src)])
        if f_id:
            return f_id[0][0]
        else:

            cols = [
                &#34;name&#34;,
                &#34;checksum&#34;,
                &#34;source&#34;,
                &#34;docstring&#34;,
                &#34;inTypes&#34;,
                &#34;outType&#34;,
                &#34;n_in&#34;,
                &#34;n_out&#34;,
            ]

            binds = [
                self.name,
                hash_(self.src),
                self.src,
                self.doc,
                str(self.inTypes),
                str(self.outTypes),
                self.nIn,
                self.nOut,
            ]

            sqlexecute(cxn, mkInsCmd(&#34;_func&#34;, cols), binds)
            f_id = sqlselect(cxn, q, [hash_(self.src)])
            return f_id[0][0]

    @staticmethod
    def path_to_func(pth: str) -&gt; C:

        try:
            spec = spec_from_file_location(&#34;random&#34;, pth)
            mod = module_from_spec(spec)
            assert spec and spec.loader, &#34;Spec or Spec.loader are broken&#34;
            spec.loader.exec_module(mod)  # type: ignore
            funcs = [
                o
                for o in getmembers(mod)
                if isfunction(o[1]) and getsourcefile(o[1]) == pth
            ]
            assert len(funcs) == 1, &#34;Bad input file %s has %d functions, not 1&#34; % (
                pth,
                len(funcs),
            )
            return funcs[0][1]

        except Exception as e:
            if exists(pth):
                with open(pth) as f:
                    content = f.read()
            raise DBgenInternalError(
                f&#34;Error while trying to load source code. You may be missing an import in your PyBlocks Env object. \nPath:{pth}\nFile Contents:\n--------\n{content}\n--------\nLoad Error: {e}&#34;
            )

    @classmethod
    def from_callable(cls, f: U[C, &#34;Func&#34;], env: Env = None) -&gt; &#34;Func&#34;:
        &#34;&#34;&#34;
        Generate a func from a variety of possible input data types.
        &#34;&#34;&#34;
        if isinstance(f, Func):
            # assert not getattr(env,&#39;imports&#39;,False)
            return f
        else:
            assert callable(f), &#34;tried to instantiate Func, but not callable %s&#34; % (
                type(f)
            )
            return Func(src=cls.get_source(f), env=env)

    @staticmethod
    def get_source(f: C) -&gt; str:
        &#34;&#34;&#34;
        Return the source code, even if it&#39;s lambda function.
        &#34;&#34;&#34;
        try:
            source_lines, _ = getsourcelines(f)
        except (IOError, TypeError,) as e:
            # functions defined in pdb / REPL / eval / some other way in which source code not clear
            import pdb

            pdb.set_trace()
            raise ValueError(&#34;from_callable: &#34;, f, e)

        # Handle &#39;def&#39;-ed functions and long lambdas
        src = &#34;&#34;.join(source_lines).strip()

        if len(source_lines) &gt; 1 and src[:3] == &#34;def&#34;:
            return src

        err = &#39;Only one &#34;lambda&#34; allowed per line: &#39;
        assert src.count(&#34;lambda&#34;) == 1, err + src

        src_ = src[src.find(&#34;lambda&#34;) :]  # start of lambda function

        # Slice off trailing chars until we get a callable function
        while len(src_) &gt; 6:
            try:
                if callable(eval(src_)):
                    return src_
            except (SyntaxError, NameError):
                pass

            src_ = src_[:-1].strip()

        raise ValueError(&#34;could not parse lambda: &#34; + src)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="dbgen.core.func.Func.from_callable"><code class="name flex">
<span>def <span class="ident">from_callable</span></span>(<span>f: Union[Callable, ForwardRef('<a title="dbgen.core.func.Func" href="#dbgen.core.func.Func">Func</a>')], env: <a title="dbgen.core.func.Env" href="#dbgen.core.func.Env">Env</a> = None) ‑> <a title="dbgen.core.func.Func" href="#dbgen.core.func.Func">Func</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate a func from a variety of possible input data types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_callable(cls, f: U[C, &#34;Func&#34;], env: Env = None) -&gt; &#34;Func&#34;:
    &#34;&#34;&#34;
    Generate a func from a variety of possible input data types.
    &#34;&#34;&#34;
    if isinstance(f, Func):
        # assert not getattr(env,&#39;imports&#39;,False)
        return f
    else:
        assert callable(f), &#34;tried to instantiate Func, but not callable %s&#34; % (
            type(f)
        )
        return Func(src=cls.get_source(f), env=env)</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.get_source"><code class="name flex">
<span>def <span class="ident">get_source</span></span>(<span>f: Callable) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the source code, even if it's lambda function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_source(f: C) -&gt; str:
    &#34;&#34;&#34;
    Return the source code, even if it&#39;s lambda function.
    &#34;&#34;&#34;
    try:
        source_lines, _ = getsourcelines(f)
    except (IOError, TypeError,) as e:
        # functions defined in pdb / REPL / eval / some other way in which source code not clear
        import pdb

        pdb.set_trace()
        raise ValueError(&#34;from_callable: &#34;, f, e)

    # Handle &#39;def&#39;-ed functions and long lambdas
    src = &#34;&#34;.join(source_lines).strip()

    if len(source_lines) &gt; 1 and src[:3] == &#34;def&#34;:
        return src

    err = &#39;Only one &#34;lambda&#34; allowed per line: &#39;
    assert src.count(&#34;lambda&#34;) == 1, err + src

    src_ = src[src.find(&#34;lambda&#34;) :]  # start of lambda function

    # Slice off trailing chars until we get a callable function
    while len(src_) &gt; 6:
        try:
            if callable(eval(src_)):
                return src_
        except (SyntaxError, NameError):
            pass

        src_ = src_[:-1].strip()

    raise ValueError(&#34;could not parse lambda: &#34; + src)</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.path_to_func"><code class="name flex">
<span>def <span class="ident">path_to_func</span></span>(<span>pth: str) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def path_to_func(pth: str) -&gt; C:

    try:
        spec = spec_from_file_location(&#34;random&#34;, pth)
        mod = module_from_spec(spec)
        assert spec and spec.loader, &#34;Spec or Spec.loader are broken&#34;
        spec.loader.exec_module(mod)  # type: ignore
        funcs = [
            o
            for o in getmembers(mod)
            if isfunction(o[1]) and getsourcefile(o[1]) == pth
        ]
        assert len(funcs) == 1, &#34;Bad input file %s has %d functions, not 1&#34; % (
            pth,
            len(funcs),
        )
        return funcs[0][1]

    except Exception as e:
        if exists(pth):
            with open(pth) as f:
                content = f.read()
        raise DBgenInternalError(
            f&#34;Error while trying to load source code. You may be missing an import in your PyBlocks Env object. \nPath:{pth}\nFile Contents:\n--------\n{content}\n--------\nLoad Error: {e}&#34;
        )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dbgen.core.func.Func.argnames"><code class="name">var <span class="ident">argnames</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def argnames(self) -&gt; L[str]:
    return list(self.sig.parameters)</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.doc"><code class="name">var <span class="ident">doc</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def doc(self) -&gt; str:
    return getdoc(self._from_src()) or &#34;&#34;</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.inTypes"><code class="name">var <span class="ident">inTypes</span> : List[<a title="dbgen.core.datatypes.DataType" href="datatypes.html#dbgen.core.datatypes.DataType">DataType</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inTypes(self) -&gt; L[DataType]:
    return [
        DataType.get_datatype(x.annotation) for x in self.sig.parameters.values()
    ]</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.is_lam"><code class="name">var <span class="ident">is_lam</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_lam(self) -&gt; bool:
    return self.src[:6] == &#34;lambda&#34;</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.nIn"><code class="name">var <span class="ident">nIn</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nIn(self) -&gt; int:
    return len(self.inTypes)</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.nOut"><code class="name">var <span class="ident">nOut</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nOut(self) -&gt; int:
    return len(self.outTypes)</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    return self._from_src().__name__</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.notImp"><code class="name">var <span class="ident">notImp</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def notImp(self) -&gt; bool:
    return &#34;NotImplementedError&#34; in self.src</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.outTypes"><code class="name">var <span class="ident">outTypes</span> : List[<a title="dbgen.core.datatypes.DataType" href="datatypes.html#dbgen.core.datatypes.DataType">DataType</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def outTypes(self) -&gt; L[DataType]:
    ot = DataType.get_datatype(self.output)
    if len(ot) == 1:
        return [ot]
    else:
        assert isinstance(ot, Tuple)
        return ot.args</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.output"><code class="name">var <span class="ident">output</span> : Any</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def output(self) -&gt; Any:
    return self.sig.return_annotation</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.sig"><code class="name">var <span class="ident">sig</span> : Any</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sig(self) -&gt; Any:
    return signature(self._from_src())</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.func.Func.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, cxn: Any) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Log function data to metaDB, return its ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, cxn: Conn) -&gt; int:
    &#34;&#34;&#34;
    Log function data to metaDB, return its ID
    &#34;&#34;&#34;
    q = mkSelectCmd(&#34;_func&#34;, [&#34;func_id&#34;], [&#34;checksum&#34;])
    f_id = sqlselect(cxn, q, [hash_(self.src)])
    if f_id:
        return f_id[0][0]
    else:

        cols = [
            &#34;name&#34;,
            &#34;checksum&#34;,
            &#34;source&#34;,
            &#34;docstring&#34;,
            &#34;inTypes&#34;,
            &#34;outType&#34;,
            &#34;n_in&#34;,
            &#34;n_out&#34;,
        ]

        binds = [
            self.name,
            hash_(self.src),
            self.src,
            self.doc,
            str(self.inTypes),
            str(self.outTypes),
            self.nIn,
            self.nOut,
        ]

        sqlexecute(cxn, mkInsCmd(&#34;_func&#34;, cols), binds)
        f_id = sqlselect(cxn, q, [hash_(self.src)])
        return f_id[0][0]</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.del_func"><code class="name flex">
<span>def <span class="ident">del_func</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Remove callable attribute after performance is no longer needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_func(self) -&gt; None:
    &#34;&#34;&#34;Remove callable attribute after performance is no longer needed&#34;&#34;&#34;
    if hasattr(self, &#34;_func&#34;):
        del self._func</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.file"><code class="name flex">
<span>def <span class="ident">file</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file(self) -&gt; str:
    lam = &#34;f = &#34; if self.is_lam else &#34;&#34;
    return str(self.env) + &#34;\n&#34; + lam + self.src</code></pre>
</details>
</dd>
<dt id="dbgen.core.func.Func.store_func"><code class="name flex">
<span>def <span class="ident">store_func</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Load func from source code and store as attribute (better performance
but object is no longer serializable / comparable for equality )</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_func(self) -&gt; None:
    &#34;&#34;&#34;Load func from source code and store as attribute (better performance
    but object is no longer serializable / comparable for equality )
    &#34;&#34;&#34;
    self._func = self._from_src()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbgen.core.func.Import"><code class="flex name class">
<span>class <span class="ident">Import</span></span>
<span>(</span><span>lib: str, unaliased_imports: Union[List[str], str] = None, lib_alias: str = '', aliased_imports: Dict[str, str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Representation of an Python import line.</p>
<p>Examples:</p>
<p>&ndash;&gt; from libname import unaliased, things, aliased as Thing
Import('libname',
&lt;---- (DO NOT make this a keyword argument!!!)
'unaliased',
'things',
aliased = 'Thing')</p>
<p>&ndash;&gt; import numpy as np
Import('numpy', alias = 'np')</p>
<p>Unsupported edge case: trying to import some variable literally named
"alias" using an alias</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Import(Base):
    &#34;&#34;&#34;
    Representation of an Python import line.

    Examples:

    --&gt; from libname import unaliased, things, aliased as Thing
        Import(&#39;libname&#39;,         &lt;---- (DO NOT make this a keyword argument!!!)
                &#39;unaliased&#39;,
                &#39;things&#39;,
                aliased = &#39;Thing&#39;)

    --&gt; import numpy as np
        Import(&#39;numpy&#39;, alias = &#39;np&#39;)

    Unsupported edge case: trying to import some variable literally named
                            &#34;alias&#34; using an alias
    &#34;&#34;&#34;

    def __init__(
        self,
        lib: str,
        unaliased_imports: U[L[str], str] = None,
        lib_alias: str = &#34;&#34;,
        aliased_imports: D[str, str] = None,
    ) -&gt; None:

        err = &#34;Can&#39;t import %s as %s AND import specific terms (%s,%s) at once&#34;
        terms = unaliased_imports or aliased_imports
        assert not (lib_alias and terms), err % (
            lib,
            lib_alias,
            unaliased_imports,
            aliased_imports,
        )

        self.lib = lib
        self.lib_alias = lib_alias

        if isinstance(unaliased_imports, str):
            self.unaliased_imports = [unaliased_imports]
        else:
            self.unaliased_imports = unaliased_imports or []
        self.aliased_imports = aliased_imports or {}
        super().__init__()

    def __str__(self) -&gt; str:
        if not (self.unaliased_imports or self.aliased_imports):
            alias = (&#34; as %s&#34; % self.lib_alias) if self.lib_alias else &#34;&#34;
            return &#34;import %s %s&#34; % (self.lib, alias)
        else:
            als = [&#34;%s as %s&#34; % (k, v) for k, v in self.aliased_imports.items()]
            terms = list(self.unaliased_imports) + als
            return &#34;from %s import %s&#34; % (self.lib, &#34;, &#34;.join(terms))

    def __eq__(self, other: object) -&gt; bool:
        return False if not isinstance(other, Import) else vars(self) == vars(other)

    def __hash__(self) -&gt; int:
        return int(self.hash)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls)

    @staticmethod
    def from_str(s: str) -&gt; &#34;Import&#34;:
        &#34;&#34;&#34;Parse a header line (parens not supported yet)&#34;&#34;&#34;
        if s[:6] == &#34;import&#34;:
            if &#34; as &#34; in s[7:]:
                lib, lib_alias = [s[7:].split(&#34;as&#34;)[i].strip() for i in range(2)]
                return Import(lib, lib_alias=lib_alias)
            return Import(s.split()[1].strip())
        else:
            i = s.find(&#34;import&#34;)
            a, lib = s[:i].split()
            assert a == &#34;from&#34;, &#34;Bad source code beginning : \n\n\n&#34; + s
            pat = r&#34;([a-zA-Z0-9\_]+\s*(?:as\s*[a-zA-Z0-9\_]+)?)&#34;
            groups = findall(pat, s[i + 6 :])
            objs = [list(map(str.strip, g.split(&#34;as&#34;))) for g in groups]
            # objs_ = [x[0] if len(x) == 1 else tuple(x) for x in objs]
            unalias = [x[0] for x in objs if len(x) == 1]
            aliased = {x[0]: x[1] for x in objs if len(x) == 2}

            return Import(lib, unaliased_imports=unalias, aliased_imports=aliased)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="dbgen.core.func.Import.from_str"><code class="name flex">
<span>def <span class="ident">from_str</span></span>(<span>s: str) ‑> <a title="dbgen.core.func.Import" href="#dbgen.core.func.Import">Import</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a header line (parens not supported yet)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_str(s: str) -&gt; &#34;Import&#34;:
    &#34;&#34;&#34;Parse a header line (parens not supported yet)&#34;&#34;&#34;
    if s[:6] == &#34;import&#34;:
        if &#34; as &#34; in s[7:]:
            lib, lib_alias = [s[7:].split(&#34;as&#34;)[i].strip() for i in range(2)]
            return Import(lib, lib_alias=lib_alias)
        return Import(s.split()[1].strip())
    else:
        i = s.find(&#34;import&#34;)
        a, lib = s[:i].split()
        assert a == &#34;from&#34;, &#34;Bad source code beginning : \n\n\n&#34; + s
        pat = r&#34;([a-zA-Z0-9\_]+\s*(?:as\s*[a-zA-Z0-9\_]+)?)&#34;
        groups = findall(pat, s[i + 6 :])
        objs = [list(map(str.strip, g.split(&#34;as&#34;))) for g in groups]
        # objs_ = [x[0] if len(x) == 1 else tuple(x) for x in objs]
        unalias = [x[0] for x in objs if len(x) == 1]
        aliased = {x[0]: x[1] for x in objs if len(x) == 2}

        return Import(lib, unaliased_imports=unalias, aliased_imports=aliased)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dbgen.core" href="index.html">dbgen.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dbgen.core.func.Env" href="#dbgen.core.func.Env">Env</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.func.Env.from_file" href="#dbgen.core.func.Env.from_file">from_file</a></code></li>
<li><code><a title="dbgen.core.func.Env.from_str" href="#dbgen.core.func.Env.from_str">from_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.func.Func" href="#dbgen.core.func.Func">Func</a></code></h4>
<ul class="two-column">
<li><code><a title="dbgen.core.func.Func.add" href="#dbgen.core.func.Func.add">add</a></code></li>
<li><code><a title="dbgen.core.func.Func.argnames" href="#dbgen.core.func.Func.argnames">argnames</a></code></li>
<li><code><a title="dbgen.core.func.Func.del_func" href="#dbgen.core.func.Func.del_func">del_func</a></code></li>
<li><code><a title="dbgen.core.func.Func.doc" href="#dbgen.core.func.Func.doc">doc</a></code></li>
<li><code><a title="dbgen.core.func.Func.file" href="#dbgen.core.func.Func.file">file</a></code></li>
<li><code><a title="dbgen.core.func.Func.from_callable" href="#dbgen.core.func.Func.from_callable">from_callable</a></code></li>
<li><code><a title="dbgen.core.func.Func.get_source" href="#dbgen.core.func.Func.get_source">get_source</a></code></li>
<li><code><a title="dbgen.core.func.Func.inTypes" href="#dbgen.core.func.Func.inTypes">inTypes</a></code></li>
<li><code><a title="dbgen.core.func.Func.is_lam" href="#dbgen.core.func.Func.is_lam">is_lam</a></code></li>
<li><code><a title="dbgen.core.func.Func.nIn" href="#dbgen.core.func.Func.nIn">nIn</a></code></li>
<li><code><a title="dbgen.core.func.Func.nOut" href="#dbgen.core.func.Func.nOut">nOut</a></code></li>
<li><code><a title="dbgen.core.func.Func.name" href="#dbgen.core.func.Func.name">name</a></code></li>
<li><code><a title="dbgen.core.func.Func.notImp" href="#dbgen.core.func.Func.notImp">notImp</a></code></li>
<li><code><a title="dbgen.core.func.Func.outTypes" href="#dbgen.core.func.Func.outTypes">outTypes</a></code></li>
<li><code><a title="dbgen.core.func.Func.output" href="#dbgen.core.func.Func.output">output</a></code></li>
<li><code><a title="dbgen.core.func.Func.path_to_func" href="#dbgen.core.func.Func.path_to_func">path_to_func</a></code></li>
<li><code><a title="dbgen.core.func.Func.sig" href="#dbgen.core.func.Func.sig">sig</a></code></li>
<li><code><a title="dbgen.core.func.Func.store_func" href="#dbgen.core.func.Func.store_func">store_func</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.func.Import" href="#dbgen.core.func.Import">Import</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.func.Import.from_str" href="#dbgen.core.func.Import.from_str">from_str</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>