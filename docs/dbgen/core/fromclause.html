<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>dbgen.core.fromclause API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dbgen.core.fromclause</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># External
from typing import TYPE_CHECKING, Set as S, List as L, Dict as D, Tuple as T, Union as U
from hashlib import md5
from base64 import b64encode
from networkx import DiGraph
from hypothesis.strategies import (
    SearchStrategy,
    builds,
    dictionaries,
    lists,
    sets,
)


from dbgen.utils.misc import Base, nonempty
from dbgen.utils.graphs import topsort_with_dict
from dbgen.utils.lists import flatten

# Internal
if TYPE_CHECKING:
    from dbgen.core.schema import Rel, SuperRel, RelTup, Obj

    Rel, SuperRel, RelTup, Obj
################################################################################


class Path(Base):
    &#34;&#34;&#34;                         
    (loop 2x)
                 -&gt;           ^|
            -&gt; C -&gt; D         |v
    A -&gt; B            -&gt; E -&gt; F -&gt; G
              -&gt; H

    Would be represented like so:
    Path(&#39;G&#39;,[fg,ff,ff,ef,[[de,[[cd1,bc,ab],
                                [cd2,bc,ab]],
                           [he,bh,ab]
                          ]])
    &#34;&#34;&#34;

    def __init__(self, end: U[str, &#34;Obj&#34;], fks: list = None) -&gt; None:
        self.end = end if isinstance(end, str) else end.name
        self.fks = fks or []
        err = &#34;expected {} in {} (objs of {})\nall fks: {}&#34;

        if fks and fks[0]:
            if isinstance(fks[0], list):
                for fk in fks[0]:
                    assert self.end in fk[0].objs, err.format(
                        self.end, fk[0].objs, fk[0], self.fks
                    )
            else:
                assert self.end in fks[0].objs, err.format(
                    self.end, fks[0].objs, fks[0], self.fks
                )
        super().__init__()

    def __str__(self) -&gt; str:
        return str(self.join())

    def __repr__(self) -&gt; str:
        return &#39;JPath(&#34;%s&#34;, %s)&#39; % (self.end, self.fks)

    def __add__(self, other: &#34;Path&#34;) -&gt; &#34;Path&#34;:
        &#34;&#34;&#34;
        Concatenate paths: tail of first must match base of second

        P1 (A --&gt; B), P2 (B --&gt; C) ==&gt; P1 + P2 (A --&gt; C)
        &#34;&#34;&#34;
        assert other.linear, &#34;Cannot concatenate paths if the second path branches&#34;
        assert (
            self.end == other.base
        ), &#34;Cannot concatenate paths unless head/tail matches&#34;
        return Path(other.end, other.fks + self.fks)

    def __sub__(self, other: &#34;Path&#34;) -&gt; &#34;Path&#34;:
        &#34;&#34;&#34;
        Take a path difference to truncate edges from the start of a path
            ... only defined under rare circumstances

        P1 (A --&gt; C), P2 (A --&gt; B) ==&gt; P1 - P2 (B --&gt; C)
        &#34;&#34;&#34;
        l2 = len(other.fks)
        err = &#34;Cannot take path difference: latter path is not subset of first&#34;
        assert self.fks[-l2:] == other.fks, err
        return Path(self.end, self.fks[:l2])

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls, end=nonempty)

    @property
    def linear(self) -&gt; bool:
        return all([not isinstance(fk, list) for fk in self.fks])

    @property
    def base(self) -&gt; str:
        &#34;&#34;&#34;The start of the current join path, defined iff it is linear&#34;&#34;&#34;
        assert self.linear
        curr = self.end
        for fk in self.fks:
            curr = fk.other(curr)
        return curr

    def all_rels(self) -&gt; S[&#34;Rel&#34;]:
        stack = self.fks
        out: S[&#34;SuperRel&#34;] = set()
        self.newmethod257(stack, out)
        return {o.to_rel() for o in out}

    def newmethod257(self, stack, out):
        while stack:
            curr = stack.pop()

            if isinstance(curr, list):
                assert not stack
                stack = flatten(curr)
            else:
                out.add(curr)

    def add(self, r: &#34;Rel&#34;) -&gt; &#34;Path&#34;:
        assert self.base in r.objs
        return Path(self.end, self.fks + [r])

    def add_branch(self, p: &#34;Path&#34;) -&gt; &#34;Path&#34;:
        c = self.copy()  # only work with a deepcopy

        # Check if this is the first branch we&#39;re adding
        if not c.fks or not isinstance(c.fks[-1], list):
            c.fks.append([p.fks])
        else:
            c.fks[-1].append(p.fks)
        return c

    def join(self) -&gt; &#34;Join&#34;:
        &#34;&#34;&#34;Get top-level join that is implied by this path.&#34;&#34;&#34;
        j = Join(self.end)
        if self.fks:
            nextfk = self.fks[0]
            if isinstance(nextfk, list):
                for nex in nextfk:
                    p = Path(nex[0].other(self.end), nex[1:])
                    j.add(p.join(), nex[0])
            else:
                nextab = nextfk.other(self.end)
                nextpath = Path(nextab, self.fks[1:])
                j.add(nextpath.join(), nextfk)
        return j

    def alljoin(self) -&gt; S[&#34;Join&#34;]:
        stack = [self.join()]
        joins = set()  # type: S[&#39;Join&#39;]
        while stack:
            curr = stack.pop()
            if curr not in joins:
                joins.add(curr)
                stack.extend(list(curr.conddict.keys()))
        return joins

    def _from(self) -&gt; &#34;From&#34;:
        return From(joins=self.alljoin())


class Join(Base):
    &#34;&#34;&#34;
    Constructed from a Path object

    Represents a table plus a unique set of JOINs that led to that table
        (accounting for multiple linear paths)
    &#34;&#34;&#34;

    def __init__(self, obj: str, conds: L[T[&#34;Join&#34;, S[&#34;SuperRel&#34;]]] = None) -&gt; None:
        assert isinstance(obj, str)
        self.obj = obj
        self.conds = conds or []
        super().__init__()

    def __str__(self) -&gt; str:
        return self.alias

    def __repr__(self) -&gt; str:
        return &#34;JOIN %s (%s)&#34; % (self.obj, &#34;,&#34;.join(map(str, self.conds)))

    def __lt__(self, other: &#34;Join&#34;) -&gt; bool:
        return str(self) &lt; str(other)

    @property
    def conddict(self) -&gt; D[&#34;Join&#34;, S[&#34;SuperRel&#34;]]:
        return dict(self.conds)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(
            cls, obj=nonempty, conds=dictionaries(Join._strat(), Rel._strat())
        )

    # Public Methods
    def add(self, j: &#34;Join&#34;, e: &#34;SuperRel&#34;) -&gt; None:
        if j in self.conddict:
            d = dict(self.conddict)
            d[j].add(e)
            self.conds = list(d.items())  # overwrite
        else:
            self.conds.append((j, {e}))

    @property
    def alias(self) -&gt; str:
        &#34;&#34;&#34;How to uniquely refer to this PATH through the schema&#34;&#34;&#34;

        if not self.conds:
            return self.obj

        s = &#34;&#34;
        for j, fks in sorted(self.conds):
            fkstr = &#34;|&#34;.join([fk.print() for fk in sorted(fks)])
            s += &#34;[(%s)#(%s)]&#34; % (fkstr, j.alias)

        data = s + self.obj
        m = md5(data.encode(&#34;ascii&#34;))
        out = b64encode(m.digest()).decode(&#34;ascii&#34;)[:3]
        return self.obj + &#34;(%s)&#34; % out

    def print(self, optional: L[&#34;RelTup&#34;] = None) -&gt; str:
        &#34;&#34;&#34;Render JOIN statement in FROM clause&#34;&#34;&#34;
        conds = [self._cond(j, e) for j, e in self.conds]  # conditions to join on
        opts = optional or []
        if not bool(conds):
            jointype = &#34; CROSS &#34;
        else:
            left = True
            # Assume a left join. if any FKs in current edge are NOT in
            # &#34;optional&#34;, then set to Inner join
            for e in self.conddict.values():
                for fk in e:  # type: ignore
                    if fk.tup() not in opts:
                        left = False
                        break
            jointype = &#34; LEFT &#34; if left else &#34; INNER &#34;
        on = (
            &#34; ON \n\t\t\t&#34; + &#34;\n\t\t\tAND &#34;.join(conds) if conds else &#34;&#34;
        )  # Possibly do not join on any condition
        args = [jointype, self.obj, self.alias, on]
        return &#39;\n\t{}JOIN {} AS &#34;{}&#34; {}&#39;.format(*args)

    # Private Methods

    def _cond(self, j: &#34;Join&#34;, rels: S[&#34;SuperRel&#34;]) -&gt; str:
        &#34;&#34;&#34;Assume the alias defined by the arg&#39;s Join has already been defined
            in the FROM statement. Write a SQL JOIN condition that will be used
            to define the current Join object&#39;s alias

            NEED TO MODIFY EVERYTHING SO THAT WE USE &lt;object&gt;.id, not &lt;object&gt;.name + &#39;_id&#39;
            &#34;&#34;&#34;

        conds = []  # type: L[str]
        for fk in rels:
            o = fk.other(self.obj)
            forward = (
                o == fk.source
            )  # Rel in forward direction. Self.obj is the &#39;old table&#39;
            aliases = [j.alias, self.alias]
            cols = (
                [fk.name, fk.target_id_str] if forward else [fk.target_id_str, fk.name]
            )
            args = [aliases[0], cols[0], aliases[1], cols[1]]
            new = &#39; &#34;{}&#34;.&#34;{}&#34; = &#34;{}&#34;.&#34;{}&#34; &#39;.format(*args)
            conds.append(new)
        return &#34;\n\t\tAND &#34;.join(conds)


class From(Base):
    &#34;&#34;&#34;
    Class used to help construct a WHERE clause.
    &#34;&#34;&#34;

    def __init__(self, basis: L[str] = None, joins: S[Join] = None) -&gt; None:
        self.joins = {Join(b) for b in basis or []} | (joins or set())
        self.basis = {j.obj for j in self.joins if not j.conds}
        super().__init__()

    # @property --- IS THIS GOING TO BREAK STUFF NOW THAT IT&#39;S A FIELD
    # def basis(self) -&gt; S[str]: return {j.obj for j in self.joins if not j.conds}

    # Public methods #
    def __str__(self) -&gt; str:
        return &#34;From(basis=%s,%d joins)&#34; % (self.basis, len(self.joins))

    def __or__(self, f: &#34;From&#34;) -&gt; &#34;From&#34;:
        return From(joins=self.joins | f.joins)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(
            cls,
            basis=lists(nonempty, min_size=1, max_size=2),
            conds=sets(Join._strat(), min_size=1, max_size=2),
        )

    def print(self, optional: L[&#34;RelTup&#34;] = None) -&gt; str:
        d = {j.alias: j for j in self.joins}
        G = DiGraph()
        G.add_nodes_from(d.keys())
        for j in self.joins:
            for j2 in j.conddict.keys():
                G.add_edge(j.alias, j2.alias)
        sort = list(reversed(topsort_with_dict(G, d)))
        start = sort[0].obj
        assert start in self.basis
        return &#34;FROM &#34; + start + &#34;&#34;.join([j.print(optional) for j in sort[1:]])

    def aliases(self) -&gt; L[str]:
        return [j.alias for j in self.joins]

    def pks(self, agg: bool = False) -&gt; str:
        col = &#39;MAX(&#34;{0}&#34;.&#34;{1}_id&#34;)&#39; if agg else &#39;&#34;{0}&#34;.&#34;{1}_id&#34;&#39;
        return &#34;,\n\t&#34;.join(
            [
                (col + &#39; AS &#34;{0}&#34; &#39;).format(a, j.obj)
                for a, j in sorted(zip(self.aliases(), self.joins))
            ]
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dbgen.core.fromclause.From"><code class="flex name class">
<span>class <span class="ident">From</span></span>
<span>(</span><span>basis: List[str] = None, joins: Set[<a title="dbgen.core.fromclause.Join" href="#dbgen.core.fromclause.Join">Join</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to help construct a WHERE clause.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class From(Base):
    &#34;&#34;&#34;
    Class used to help construct a WHERE clause.
    &#34;&#34;&#34;

    def __init__(self, basis: L[str] = None, joins: S[Join] = None) -&gt; None:
        self.joins = {Join(b) for b in basis or []} | (joins or set())
        self.basis = {j.obj for j in self.joins if not j.conds}
        super().__init__()

    # @property --- IS THIS GOING TO BREAK STUFF NOW THAT IT&#39;S A FIELD
    # def basis(self) -&gt; S[str]: return {j.obj for j in self.joins if not j.conds}

    # Public methods #
    def __str__(self) -&gt; str:
        return &#34;From(basis=%s,%d joins)&#34; % (self.basis, len(self.joins))

    def __or__(self, f: &#34;From&#34;) -&gt; &#34;From&#34;:
        return From(joins=self.joins | f.joins)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(
            cls,
            basis=lists(nonempty, min_size=1, max_size=2),
            conds=sets(Join._strat(), min_size=1, max_size=2),
        )

    def print(self, optional: L[&#34;RelTup&#34;] = None) -&gt; str:
        d = {j.alias: j for j in self.joins}
        G = DiGraph()
        G.add_nodes_from(d.keys())
        for j in self.joins:
            for j2 in j.conddict.keys():
                G.add_edge(j.alias, j2.alias)
        sort = list(reversed(topsort_with_dict(G, d)))
        start = sort[0].obj
        assert start in self.basis
        return &#34;FROM &#34; + start + &#34;&#34;.join([j.print(optional) for j in sort[1:]])

    def aliases(self) -&gt; L[str]:
        return [j.alias for j in self.joins]

    def pks(self, agg: bool = False) -&gt; str:
        col = &#39;MAX(&#34;{0}&#34;.&#34;{1}_id&#34;)&#39; if agg else &#39;&#34;{0}&#34;.&#34;{1}_id&#34;&#39;
        return &#34;,\n\t&#34;.join(
            [
                (col + &#39; AS &#34;{0}&#34; &#39;).format(a, j.obj)
                for a, j in sorted(zip(self.aliases(), self.joins))
            ]
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.fromclause.From.aliases"><code class="name flex">
<span>def <span class="ident">aliases</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aliases(self) -&gt; L[str]:
    return [j.alias for j in self.joins]</code></pre>
</details>
</dd>
<dt id="dbgen.core.fromclause.From.pks"><code class="name flex">
<span>def <span class="ident">pks</span></span>(<span>self, agg: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pks(self, agg: bool = False) -&gt; str:
    col = &#39;MAX(&#34;{0}&#34;.&#34;{1}_id&#34;)&#39; if agg else &#39;&#34;{0}&#34;.&#34;{1}_id&#34;&#39;
    return &#34;,\n\t&#34;.join(
        [
            (col + &#39; AS &#34;{0}&#34; &#39;).format(a, j.obj)
            for a, j in sorted(zip(self.aliases(), self.joins))
        ]
    )</code></pre>
</details>
</dd>
<dt id="dbgen.core.fromclause.From.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, optional: List[ForwardRef('RelTup')] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, optional: L[&#34;RelTup&#34;] = None) -&gt; str:
    d = {j.alias: j for j in self.joins}
    G = DiGraph()
    G.add_nodes_from(d.keys())
    for j in self.joins:
        for j2 in j.conddict.keys():
            G.add_edge(j.alias, j2.alias)
    sort = list(reversed(topsort_with_dict(G, d)))
    start = sort[0].obj
    assert start in self.basis
    return &#34;FROM &#34; + start + &#34;&#34;.join([j.print(optional) for j in sort[1:]])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbgen.core.fromclause.Join"><code class="flex name class">
<span>class <span class="ident">Join</span></span>
<span>(</span><span>obj: str, conds: List[Tuple[ForwardRef('<a title="dbgen.core.fromclause.Join" href="#dbgen.core.fromclause.Join">Join</a>'), Set[ForwardRef('SuperRel')]]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructed from a Path object</p>
<p>Represents a table plus a unique set of JOINs that led to that table
(accounting for multiple linear paths)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Join(Base):
    &#34;&#34;&#34;
    Constructed from a Path object

    Represents a table plus a unique set of JOINs that led to that table
        (accounting for multiple linear paths)
    &#34;&#34;&#34;

    def __init__(self, obj: str, conds: L[T[&#34;Join&#34;, S[&#34;SuperRel&#34;]]] = None) -&gt; None:
        assert isinstance(obj, str)
        self.obj = obj
        self.conds = conds or []
        super().__init__()

    def __str__(self) -&gt; str:
        return self.alias

    def __repr__(self) -&gt; str:
        return &#34;JOIN %s (%s)&#34; % (self.obj, &#34;,&#34;.join(map(str, self.conds)))

    def __lt__(self, other: &#34;Join&#34;) -&gt; bool:
        return str(self) &lt; str(other)

    @property
    def conddict(self) -&gt; D[&#34;Join&#34;, S[&#34;SuperRel&#34;]]:
        return dict(self.conds)

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(
            cls, obj=nonempty, conds=dictionaries(Join._strat(), Rel._strat())
        )

    # Public Methods
    def add(self, j: &#34;Join&#34;, e: &#34;SuperRel&#34;) -&gt; None:
        if j in self.conddict:
            d = dict(self.conddict)
            d[j].add(e)
            self.conds = list(d.items())  # overwrite
        else:
            self.conds.append((j, {e}))

    @property
    def alias(self) -&gt; str:
        &#34;&#34;&#34;How to uniquely refer to this PATH through the schema&#34;&#34;&#34;

        if not self.conds:
            return self.obj

        s = &#34;&#34;
        for j, fks in sorted(self.conds):
            fkstr = &#34;|&#34;.join([fk.print() for fk in sorted(fks)])
            s += &#34;[(%s)#(%s)]&#34; % (fkstr, j.alias)

        data = s + self.obj
        m = md5(data.encode(&#34;ascii&#34;))
        out = b64encode(m.digest()).decode(&#34;ascii&#34;)[:3]
        return self.obj + &#34;(%s)&#34; % out

    def print(self, optional: L[&#34;RelTup&#34;] = None) -&gt; str:
        &#34;&#34;&#34;Render JOIN statement in FROM clause&#34;&#34;&#34;
        conds = [self._cond(j, e) for j, e in self.conds]  # conditions to join on
        opts = optional or []
        if not bool(conds):
            jointype = &#34; CROSS &#34;
        else:
            left = True
            # Assume a left join. if any FKs in current edge are NOT in
            # &#34;optional&#34;, then set to Inner join
            for e in self.conddict.values():
                for fk in e:  # type: ignore
                    if fk.tup() not in opts:
                        left = False
                        break
            jointype = &#34; LEFT &#34; if left else &#34; INNER &#34;
        on = (
            &#34; ON \n\t\t\t&#34; + &#34;\n\t\t\tAND &#34;.join(conds) if conds else &#34;&#34;
        )  # Possibly do not join on any condition
        args = [jointype, self.obj, self.alias, on]
        return &#39;\n\t{}JOIN {} AS &#34;{}&#34; {}&#39;.format(*args)

    # Private Methods

    def _cond(self, j: &#34;Join&#34;, rels: S[&#34;SuperRel&#34;]) -&gt; str:
        &#34;&#34;&#34;Assume the alias defined by the arg&#39;s Join has already been defined
            in the FROM statement. Write a SQL JOIN condition that will be used
            to define the current Join object&#39;s alias

            NEED TO MODIFY EVERYTHING SO THAT WE USE &lt;object&gt;.id, not &lt;object&gt;.name + &#39;_id&#39;
            &#34;&#34;&#34;

        conds = []  # type: L[str]
        for fk in rels:
            o = fk.other(self.obj)
            forward = (
                o == fk.source
            )  # Rel in forward direction. Self.obj is the &#39;old table&#39;
            aliases = [j.alias, self.alias]
            cols = (
                [fk.name, fk.target_id_str] if forward else [fk.target_id_str, fk.name]
            )
            args = [aliases[0], cols[0], aliases[1], cols[1]]
            new = &#39; &#34;{}&#34;.&#34;{}&#34; = &#34;{}&#34;.&#34;{}&#34; &#39;.format(*args)
            conds.append(new)
        return &#34;\n\t\tAND &#34;.join(conds)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="dbgen.core.fromclause.Join.alias"><code class="name">var <span class="ident">alias</span> : str</code></dt>
<dd>
<div class="desc"><p>How to uniquely refer to this PATH through the schema</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def alias(self) -&gt; str:
    &#34;&#34;&#34;How to uniquely refer to this PATH through the schema&#34;&#34;&#34;

    if not self.conds:
        return self.obj

    s = &#34;&#34;
    for j, fks in sorted(self.conds):
        fkstr = &#34;|&#34;.join([fk.print() for fk in sorted(fks)])
        s += &#34;[(%s)#(%s)]&#34; % (fkstr, j.alias)

    data = s + self.obj
    m = md5(data.encode(&#34;ascii&#34;))
    out = b64encode(m.digest()).decode(&#34;ascii&#34;)[:3]
    return self.obj + &#34;(%s)&#34; % out</code></pre>
</details>
</dd>
<dt id="dbgen.core.fromclause.Join.conddict"><code class="name">var <span class="ident">conddict</span> : Dict[ForwardRef('<a title="dbgen.core.fromclause.Join" href="#dbgen.core.fromclause.Join">Join</a>'), Set[ForwardRef('SuperRel')]]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def conddict(self) -&gt; D[&#34;Join&#34;, S[&#34;SuperRel&#34;]]:
    return dict(self.conds)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.fromclause.Join.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, j: <a title="dbgen.core.fromclause.Join" href="#dbgen.core.fromclause.Join">Join</a>, e: SuperRel)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, j: &#34;Join&#34;, e: &#34;SuperRel&#34;) -&gt; None:
    if j in self.conddict:
        d = dict(self.conddict)
        d[j].add(e)
        self.conds = list(d.items())  # overwrite
    else:
        self.conds.append((j, {e}))</code></pre>
</details>
</dd>
<dt id="dbgen.core.fromclause.Join.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, optional: List[ForwardRef('RelTup')] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Render JOIN statement in FROM clause</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, optional: L[&#34;RelTup&#34;] = None) -&gt; str:
    &#34;&#34;&#34;Render JOIN statement in FROM clause&#34;&#34;&#34;
    conds = [self._cond(j, e) for j, e in self.conds]  # conditions to join on
    opts = optional or []
    if not bool(conds):
        jointype = &#34; CROSS &#34;
    else:
        left = True
        # Assume a left join. if any FKs in current edge are NOT in
        # &#34;optional&#34;, then set to Inner join
        for e in self.conddict.values():
            for fk in e:  # type: ignore
                if fk.tup() not in opts:
                    left = False
                    break
        jointype = &#34; LEFT &#34; if left else &#34; INNER &#34;
    on = (
        &#34; ON \n\t\t\t&#34; + &#34;\n\t\t\tAND &#34;.join(conds) if conds else &#34;&#34;
    )  # Possibly do not join on any condition
    args = [jointype, self.obj, self.alias, on]
    return &#39;\n\t{}JOIN {} AS &#34;{}&#34; {}&#39;.format(*args)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbgen.core.fromclause.Path"><code class="flex name class">
<span>class <span class="ident">Path</span></span>
<span>(</span><span>end: Union[str, ForwardRef('Obj')], fks: list = None)</span>
</code></dt>
<dd>
<div class="desc"><p>(loop 2x)
-&gt;
^|
-&gt; C -&gt; D
|v
A -&gt; B
-&gt; E -&gt; F -&gt; G
-&gt; H</p>
<p>Would be represented like so:
Path('G',[fg,ff,ff,ef,[[de,[[cd1,bc,ab],
[cd2,bc,ab]],
[he,bh,ab]
]])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Path(Base):
    &#34;&#34;&#34;                         
    (loop 2x)
                 -&gt;           ^|
            -&gt; C -&gt; D         |v
    A -&gt; B            -&gt; E -&gt; F -&gt; G
              -&gt; H

    Would be represented like so:
    Path(&#39;G&#39;,[fg,ff,ff,ef,[[de,[[cd1,bc,ab],
                                [cd2,bc,ab]],
                           [he,bh,ab]
                          ]])
    &#34;&#34;&#34;

    def __init__(self, end: U[str, &#34;Obj&#34;], fks: list = None) -&gt; None:
        self.end = end if isinstance(end, str) else end.name
        self.fks = fks or []
        err = &#34;expected {} in {} (objs of {})\nall fks: {}&#34;

        if fks and fks[0]:
            if isinstance(fks[0], list):
                for fk in fks[0]:
                    assert self.end in fk[0].objs, err.format(
                        self.end, fk[0].objs, fk[0], self.fks
                    )
            else:
                assert self.end in fks[0].objs, err.format(
                    self.end, fks[0].objs, fks[0], self.fks
                )
        super().__init__()

    def __str__(self) -&gt; str:
        return str(self.join())

    def __repr__(self) -&gt; str:
        return &#39;JPath(&#34;%s&#34;, %s)&#39; % (self.end, self.fks)

    def __add__(self, other: &#34;Path&#34;) -&gt; &#34;Path&#34;:
        &#34;&#34;&#34;
        Concatenate paths: tail of first must match base of second

        P1 (A --&gt; B), P2 (B --&gt; C) ==&gt; P1 + P2 (A --&gt; C)
        &#34;&#34;&#34;
        assert other.linear, &#34;Cannot concatenate paths if the second path branches&#34;
        assert (
            self.end == other.base
        ), &#34;Cannot concatenate paths unless head/tail matches&#34;
        return Path(other.end, other.fks + self.fks)

    def __sub__(self, other: &#34;Path&#34;) -&gt; &#34;Path&#34;:
        &#34;&#34;&#34;
        Take a path difference to truncate edges from the start of a path
            ... only defined under rare circumstances

        P1 (A --&gt; C), P2 (A --&gt; B) ==&gt; P1 - P2 (B --&gt; C)
        &#34;&#34;&#34;
        l2 = len(other.fks)
        err = &#34;Cannot take path difference: latter path is not subset of first&#34;
        assert self.fks[-l2:] == other.fks, err
        return Path(self.end, self.fks[:l2])

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        return builds(cls, end=nonempty)

    @property
    def linear(self) -&gt; bool:
        return all([not isinstance(fk, list) for fk in self.fks])

    @property
    def base(self) -&gt; str:
        &#34;&#34;&#34;The start of the current join path, defined iff it is linear&#34;&#34;&#34;
        assert self.linear
        curr = self.end
        for fk in self.fks:
            curr = fk.other(curr)
        return curr

    def all_rels(self) -&gt; S[&#34;Rel&#34;]:
        stack = self.fks
        out: S[&#34;SuperRel&#34;] = set()
        self.newmethod257(stack, out)
        return {o.to_rel() for o in out}

    def newmethod257(self, stack, out):
        while stack:
            curr = stack.pop()

            if isinstance(curr, list):
                assert not stack
                stack = flatten(curr)
            else:
                out.add(curr)

    def add(self, r: &#34;Rel&#34;) -&gt; &#34;Path&#34;:
        assert self.base in r.objs
        return Path(self.end, self.fks + [r])

    def add_branch(self, p: &#34;Path&#34;) -&gt; &#34;Path&#34;:
        c = self.copy()  # only work with a deepcopy

        # Check if this is the first branch we&#39;re adding
        if not c.fks or not isinstance(c.fks[-1], list):
            c.fks.append([p.fks])
        else:
            c.fks[-1].append(p.fks)
        return c

    def join(self) -&gt; &#34;Join&#34;:
        &#34;&#34;&#34;Get top-level join that is implied by this path.&#34;&#34;&#34;
        j = Join(self.end)
        if self.fks:
            nextfk = self.fks[0]
            if isinstance(nextfk, list):
                for nex in nextfk:
                    p = Path(nex[0].other(self.end), nex[1:])
                    j.add(p.join(), nex[0])
            else:
                nextab = nextfk.other(self.end)
                nextpath = Path(nextab, self.fks[1:])
                j.add(nextpath.join(), nextfk)
        return j

    def alljoin(self) -&gt; S[&#34;Join&#34;]:
        stack = [self.join()]
        joins = set()  # type: S[&#39;Join&#39;]
        while stack:
            curr = stack.pop()
            if curr not in joins:
                joins.add(curr)
                stack.extend(list(curr.conddict.keys()))
        return joins

    def _from(self) -&gt; &#34;From&#34;:
        return From(joins=self.alljoin())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="dbgen.core.fromclause.Path.base"><code class="name">var <span class="ident">base</span> : str</code></dt>
<dd>
<div class="desc"><p>The start of the current join path, defined iff it is linear</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base(self) -&gt; str:
    &#34;&#34;&#34;The start of the current join path, defined iff it is linear&#34;&#34;&#34;
    assert self.linear
    curr = self.end
    for fk in self.fks:
        curr = fk.other(curr)
    return curr</code></pre>
</details>
</dd>
<dt id="dbgen.core.fromclause.Path.linear"><code class="name">var <span class="ident">linear</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def linear(self) -&gt; bool:
    return all([not isinstance(fk, list) for fk in self.fks])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.fromclause.Path.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, r: Rel) ‑> '<a title="dbgen.core.fromclause.Path" href="#dbgen.core.fromclause.Path">Path</a>'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, r: &#34;Rel&#34;) -&gt; &#34;Path&#34;:
    assert self.base in r.objs
    return Path(self.end, self.fks + [r])</code></pre>
</details>
</dd>
<dt id="dbgen.core.fromclause.Path.add_branch"><code class="name flex">
<span>def <span class="ident">add_branch</span></span>(<span>self, p: <a title="dbgen.core.fromclause.Path" href="#dbgen.core.fromclause.Path">Path</a>) ‑> <a title="dbgen.core.fromclause.Path" href="#dbgen.core.fromclause.Path">Path</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_branch(self, p: &#34;Path&#34;) -&gt; &#34;Path&#34;:
    c = self.copy()  # only work with a deepcopy

    # Check if this is the first branch we&#39;re adding
    if not c.fks or not isinstance(c.fks[-1], list):
        c.fks.append([p.fks])
    else:
        c.fks[-1].append(p.fks)
    return c</code></pre>
</details>
</dd>
<dt id="dbgen.core.fromclause.Path.all_rels"><code class="name flex">
<span>def <span class="ident">all_rels</span></span>(<span>self) ‑> Set[ForwardRef('Rel')]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_rels(self) -&gt; S[&#34;Rel&#34;]:
    stack = self.fks
    out: S[&#34;SuperRel&#34;] = set()
    self.newmethod257(stack, out)
    return {o.to_rel() for o in out}</code></pre>
</details>
</dd>
<dt id="dbgen.core.fromclause.Path.alljoin"><code class="name flex">
<span>def <span class="ident">alljoin</span></span>(<span>self) ‑> Set[<a title="dbgen.core.fromclause.Join" href="#dbgen.core.fromclause.Join">Join</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alljoin(self) -&gt; S[&#34;Join&#34;]:
    stack = [self.join()]
    joins = set()  # type: S[&#39;Join&#39;]
    while stack:
        curr = stack.pop()
        if curr not in joins:
            joins.add(curr)
            stack.extend(list(curr.conddict.keys()))
    return joins</code></pre>
</details>
</dd>
<dt id="dbgen.core.fromclause.Path.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self) ‑> <a title="dbgen.core.fromclause.Join" href="#dbgen.core.fromclause.Join">Join</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get top-level join that is implied by this path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self) -&gt; &#34;Join&#34;:
    &#34;&#34;&#34;Get top-level join that is implied by this path.&#34;&#34;&#34;
    j = Join(self.end)
    if self.fks:
        nextfk = self.fks[0]
        if isinstance(nextfk, list):
            for nex in nextfk:
                p = Path(nex[0].other(self.end), nex[1:])
                j.add(p.join(), nex[0])
        else:
            nextab = nextfk.other(self.end)
            nextpath = Path(nextab, self.fks[1:])
            j.add(nextpath.join(), nextfk)
    return j</code></pre>
</details>
</dd>
<dt id="dbgen.core.fromclause.Path.newmethod257"><code class="name flex">
<span>def <span class="ident">newmethod257</span></span>(<span>self, stack, out)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newmethod257(self, stack, out):
    while stack:
        curr = stack.pop()

        if isinstance(curr, list):
            assert not stack
            stack = flatten(curr)
        else:
            out.add(curr)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dbgen.core" href="index.html">dbgen.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dbgen.core.fromclause.From" href="#dbgen.core.fromclause.From">From</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.fromclause.From.aliases" href="#dbgen.core.fromclause.From.aliases">aliases</a></code></li>
<li><code><a title="dbgen.core.fromclause.From.pks" href="#dbgen.core.fromclause.From.pks">pks</a></code></li>
<li><code><a title="dbgen.core.fromclause.From.print" href="#dbgen.core.fromclause.From.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.fromclause.Join" href="#dbgen.core.fromclause.Join">Join</a></code></h4>
<ul class="">
<li><code><a title="dbgen.core.fromclause.Join.add" href="#dbgen.core.fromclause.Join.add">add</a></code></li>
<li><code><a title="dbgen.core.fromclause.Join.alias" href="#dbgen.core.fromclause.Join.alias">alias</a></code></li>
<li><code><a title="dbgen.core.fromclause.Join.conddict" href="#dbgen.core.fromclause.Join.conddict">conddict</a></code></li>
<li><code><a title="dbgen.core.fromclause.Join.print" href="#dbgen.core.fromclause.Join.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbgen.core.fromclause.Path" href="#dbgen.core.fromclause.Path">Path</a></code></h4>
<ul class="two-column">
<li><code><a title="dbgen.core.fromclause.Path.add" href="#dbgen.core.fromclause.Path.add">add</a></code></li>
<li><code><a title="dbgen.core.fromclause.Path.add_branch" href="#dbgen.core.fromclause.Path.add_branch">add_branch</a></code></li>
<li><code><a title="dbgen.core.fromclause.Path.all_rels" href="#dbgen.core.fromclause.Path.all_rels">all_rels</a></code></li>
<li><code><a title="dbgen.core.fromclause.Path.alljoin" href="#dbgen.core.fromclause.Path.alljoin">alljoin</a></code></li>
<li><code><a title="dbgen.core.fromclause.Path.base" href="#dbgen.core.fromclause.Path.base">base</a></code></li>
<li><code><a title="dbgen.core.fromclause.Path.join" href="#dbgen.core.fromclause.Path.join">join</a></code></li>
<li><code><a title="dbgen.core.fromclause.Path.linear" href="#dbgen.core.fromclause.Path.linear">linear</a></code></li>
<li><code><a title="dbgen.core.fromclause.Path.newmethod257" href="#dbgen.core.fromclause.Path.newmethod257">newmethod257</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>