<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>dbgen.core.action API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dbgen.core.action</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># External Modules
from typing import TYPE_CHECKING, List as L, Dict as D, Tuple as T
import logging
import psycopg2
from psycopg2.errors import QueryCanceled
import re
from jinja2 import Template
from io import StringIO
from random import getrandbits
from hypothesis.strategies import (
    SearchStrategy,
    builds,
    just,
    one_of,
    dictionaries,
)


from dbgen.core.funclike import ArgLike, Arg, Const
from dbgen.utils.exceptions import Psycopg2Error, DBgenExternalError
from dbgen.utils.misc import Base, nonempty
from dbgen.utils.str_utils import hashdata_
from dbgen.utils.lists import broadcast
from dbgen.utils.sql import Connection as Conn
from dbgen.templates import jinja_env

# Internal Modules
if TYPE_CHECKING:
    from dbgen.core.schema import Obj, Rel

    Obj, Rel

&#34;&#34;&#34;
Defines the class of modifications to a database

There is a horrific amount of duplicated code in this file...... oughta fixit
&#34;&#34;&#34;
################################################################################
# ######################
# # Constants
# # --------------------
NUM_QUERY_TRIES = 3


class Action(Base):
    &#34;&#34;&#34;
    The purpose for this object is to make an easily serializable data structure
    that knows how to update the database (these methods could easily be for
    Model, but we don&#39;t want to send the entire model just to do this small thing)
    &#34;&#34;&#34;

    def __init__(
        self,
        obj: str,
        attrs: D[str, ArgLike],
        fks: D[str, &#34;Action&#34;],
        pk: Arg = None,
        insert: bool = False,
    ) -&gt; None:

        self.obj = obj.lower()
        self.attrs = {k.lower(): v for k, v in attrs.items()}
        self.fks = {k.lower(): v for k, v in fks.items()}
        self.pk = pk
        self.insert = insert
        self._logger = logging.getLogger(f&#34;dbgen.run.loading.{self.obj}&#34;)
        self._logger.setLevel(logging.DEBUG)
        err = &#34;Cant insert %s if we already have PK %s&#34;
        assert (pk is None) or (not insert), err % (obj, pk)
        if isinstance(pk, Const) and pk == Const(None):
            pass
        else:
            assert isinstance(pk, (Arg, type(None))), (
                obj,
                attrs,
                fks,
                pk,
                insert,
            )
        super().__init__()

    def __str__(self) -&gt; str:
        n = len(self.attrs)
        m = len(self.fks)
        return &#34;Action&lt;%s, %d attr, %d rel&gt;&#34; % (self.obj, n, m)

    ##################
    # Public methods #
    ###################
    def tabdeps(self) -&gt; L[str]:
        &#34;&#34;&#34;All tables that are updated (they must already exist, is the logic)&#34;&#34;&#34;
        deps = []
        # Check if we are updating; if so we depend on
        if not self.insert:
            deps.append(self.obj)
        for fk in self.fks.values():
            if fk.pk is not None:
                deps.extend(fk.tabdeps())
        return deps

    def newtabs(self) -&gt; L[str]:
        &#34;&#34;&#34;All tables that could be inserted into this action&#34;&#34;&#34;
        out = [self.obj] if self.insert else []
        for a in self.fks.values():
            out.extend(a.newtabs())
        return out

    def newcols(self, universe: D[str, &#34;Obj&#34;]) -&gt; L[str]:
        &#34;&#34;&#34;All attributes that could be populated by this action&#34;&#34;&#34;
        obj = universe[self.obj]
        out = [
            self.obj + &#34;.&#34; + a
            for a in self.attrs.keys()
            if (self.insert or (a not in obj.ids()))
        ]
        for k, a in self.fks.items():
            if self.insert or (k not in obj.id_fks()):
                try:
                    out.extend([self.obj + &#34;.&#34; + k] + a.newcols(universe))
                except KeyError:
                    import pdb

                    pdb.set_trace()
        return out

    def act(
        self,
        cxn: Conn,
        objs: D[str, T[str, L[str], L[str]]],
        rows: L[dict],
        gen_name: str,
    ) -&gt; None:
        &#34;&#34;&#34;
        Top level call from a Generator to execute an action (top level is
        always insert or update, never just a select)
        &#34;&#34;&#34;
        # Initialize logger
        self._load(cxn, objs, rows, insert=self.insert)

    def rename_object(self, o: &#34;Obj&#34;, n: str) -&gt; &#34;Action&#34;:
        &#34;&#34;&#34;Replaces all references to a given object to one having a new name&#34;&#34;&#34;
        a = self.copy()
        if a.obj == o.name:
            a.obj = n
        for k, v in a.fks.items():
            a.fks[k] = v.rename_object(o, n)
        return a

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        &#34;&#34;&#34;A hypothesis strategy for generating random examples.&#34;&#34;&#34;

        common_action_kwargs = dict(
            obj=nonempty, attrs=dictionaries(keys=nonempty, values=ArgLike._strat()),
        )
        action_ = builds(
            cls,
            fks=just(dict()),
            pk=Arg._strat(),
            insert=just(False),
            **common_action_kwargs,  # type: ignore
        )
        action0 = builds(
            cls,
            fks=dictionaries(keys=nonempty, values=action_),
            pk=Arg._strat(),
            insert=just(False),
            **common_action_kwargs,  # type: ignore
        )
        action1 = builds(
            cls,
            fks=dictionaries(keys=nonempty, values=action_),
            pk=just(None),
            insert=just(True),
            **common_action_kwargs,  # type: ignore
        )
        return one_of(action_, action0, action1)

    ###################
    # Private methods #
    ###################

    def _getvals(
        self, objs: D[str, T[str, L[str], L[str]]], row: dict,
    ) -&gt; T[L[str], L[tuple]]:
        &#34;&#34;&#34;
        Get a broadcasted list of INSERT/UPDATE values for an object, given
        Pyblock+Query output
        &#34;&#34;&#34;

        idattr, allattr = [], []
        obj_pk_name, ids, id_fks = objs[self.obj]
        for k, v in sorted(self.attrs.items(),):
            val = v.arg_get(row)
            allattr.append(val)
            if k in ids:
                idattr.append(val)

        for kk, vv in sorted(self.fks.items()):
            if vv.pk is not None:
                val = vv.pk.arg_get(row)
            else:
                val, fk_adata = vv._getvals(objs, row)

            allattr.append(val)
            if kk in id_fks:
                idattr.append(val)

        idata: L[tuple] = broadcast(idattr)
        adata: L[tuple] = broadcast(allattr)
        if self.pk is not None:
            assert not idata, &#34;Cannot provide a PK *and* identifying info&#34;
            pkdata = self.pk.arg_get(row)
            if isinstance(pkdata, int):
                idata_prime = [str(pkdata)]
            elif isinstance(pkdata, list) and isinstance(pkdata[0], int):  # HACKY
                idata_prime = pkdata
            elif isinstance(pkdata, str):
                idata_prime = [pkdata]
            elif isinstance(pkdata, list) and isinstance(pkdata[0], str):  # HACKY

                idata_prime = pkdata
            else:
                raise TypeError(
                    &#34;PK should either receive an int or a list of ints&#34;, vars(self)
                )
        else:
            idata_prime = []
            idata_dict = {}  # type: D[tuple,str]
            # Iterate through the identifying data and cache the hashed result for speed
            for idata_curr in idata:
                if idata_dict.get(idata_curr) is None:
                    idata_dict[idata_curr] = hashdata_(idata_curr)
                idata_prime.append(idata_dict[idata_curr])

        if len(idata_prime) == 1:
            idata_prime *= len(adata)  # broadcast

        lenerr = &#34;Cannot match IDs to data: %d!=%d&#34;
        assert len(idata_prime) == len(adata), lenerr % (len(idata_prime), len(adata))
        return idata_prime, adata

    def _data_to_stringIO(
        self, pk: L[str], data: L[tuple], obj_pk_name: str,
    ) -&gt; StringIO:
        &#34;&#34;&#34;
        Function takes in a path to a delimited file and returns a IO object
        where the identifying columns have been hashed into a primary key in the
        first ordinal position of the table. The hash uses the id_column_names
        so that only ID info is hashed into the hash value
        &#34;&#34;&#34;
        # All ro
        output_file_obj = StringIO()
        for i, (pk_curr, row_curr) in enumerate(set(zip(pk, data))):
            new_line = [pk_curr] + list(row_curr)  # type: ignore
            new_line = map(str, new_line)  # type: ignore
            new_line = map(  # type: ignore
                lambda x: x.replace(&#34;\t&#34;, &#34;\\t&#34;)
                .replace(&#34;\n&#34;, &#34;\\n&#34;)
                .replace(&#34;\r&#34;, &#34;\\r&#34;)
                .replace(&#34;\\&#34;, &#34;\\\\&#34;),
                new_line,
            )
            output_file_obj.write(&#34;\t&#34;.join(new_line) + &#34;\n&#34;)  # type: ignore

        output_file_obj.seek(0)

        return output_file_obj

    def _load(
        self,
        cxn: Conn,
        objs: D[str, T[str, L[str], L[str]]],
        rows: L[dict],
        insert: bool,
        test: bool = False,
    ) -&gt; L[int]:
        &#34;&#34;&#34;
        Helpful docstring
        &#34;&#34;&#34;
        self._logger.debug(&#34;recursively loading foreign keys&#34;)
        for kk, vv in self.fks.items():
            if vv.insert:
                vv._load(cxn, objs, rows, insert=True, test=test)

        self._logger.debug(&#34;Getting attributes and generating hashes&#34;)
        obj_pk_name, ids, id_fks = objs[self.obj]
        pk, data = [], []
        for row in rows:
            pk_curr, data_curr = self._getvals(objs, row)
            pk.extend(pk_curr)
            data.extend(data_curr)

        self._logger.debug(&#34;writing data to stringio object&#34;)
        io_obj = self._data_to_stringIO(pk, data, obj_pk_name)
        if not data:
            return []

        # If we are testing don&#39;t try and do sql
        if not test:
            self._load_data(cxn, obj_pk_name, io_obj, insert)

        return [int(x) for x in pk]

    def _load_data(
        self, cxn: Conn, obj_pk_name: str, io_obj: StringIO, insert: bool
    ) -&gt; None:
        &#34;&#34;&#34;
        Function that quickly loads an io_obj import the database specified
        obj_pk_name. Insert flag determines whether we update or insert.

        Args:
            cxn (Conn): connection to database to load intop
            obj_pk_name (str): name of objects primary key name
            io_obj (StringIO): StringIO to use for copy_from into database
            insert (bool): whether or not to update or insert into database

        Raises:
            ValueError: [description]
            DBgenExternalError: [description]
            ValueError: [description]
        &#34;&#34;&#34;
        # Temporary table to copy data into
        # Set name to be hash of input rows to ensure uniqueness for parallelization
        temp_table_name = self.obj + &#34;_temp_load_table_&#34; + str(getrandbits(64))

        # Need to create a temp table to copy data into
        # Add an auto_inc column so that data can be ordered by its insert location
        create_temp_table = &#34;&#34;&#34;
        DROP TABLE IF EXISTS {temp_table_name};
        CREATE TEMPORARY TABLE {temp_table_name} AS
        TABLE {obj}
        WITH NO DATA;
        ALTER TABLE {temp_table_name}
        ADD COLUMN auto_inc SERIAL NOT NULL;
        &#34;&#34;&#34;.format(
            obj=self.obj, temp_table_name=temp_table_name
        )

        cols = (
            [obj_pk_name]
            + list(sorted(self.attrs.keys()))
            + list(sorted(self.fks.keys()))
        )
        escaped_cols = [&#39;&#34;&#39; + col + &#39;&#34;&#39; for col in cols]
        if insert:
            template = jinja_env.get_template(&#34;insert.sql.jinja&#34;)
        else:
            template = jinja_env.get_template(&#34;update.sql.jinja&#34;)

        first = False
        update = True
        fk_cols = self.fks.keys()
        template_args = dict(
            obj=self.obj,
            obj_pk_name=obj_pk_name,
            temp_table_name=temp_table_name,
            all_column_names=cols,
            fk_cols=fk_cols,
            first=first,
            update=update,
        )
        load_statement = template.render(**template_args)

        with cxn.cursor() as curs:
            # Create the temp table
            curs.execute(create_temp_table)
            # Attempt the loading step 3 times
            self._logger.debug(&#34;load into temporary table&#34;)
            query_fail_count = 0
            while True:
                if query_fail_count == NUM_QUERY_TRIES:
                    raise ValueError(&#34;Query Cancel fail max reached&#34;)
                try:
                    curs.copy_from(
                        io_obj, temp_table_name, null=&#34;None&#34;, columns=escaped_cols
                    )
                    break
                except QueryCanceled:
                    print(&#34;Query cancel failed&#34;)
                    query_fail_count += 1
                    continue
                except Psycopg2Error as exc:
                    raise DBgenExternalError(exc.pgerror)

            # Try to insert everything from the temp table into the real table
            # If a foreign_key violation is hit, we delete those rows in the
            # temp table and move on
            fk_fail_count = 0
            self._logger.debug(&#34;transfer from temp table to main table&#34;)
            while True:
                if fk_fail_count == 10:
                    raise ValueError(
                        &#34;User Canceled due to large number of FK violations&#34;
                    )
                # check for ForeignKeyViolation error
                try:
                    curs.execute(load_statement)
                    break
                except psycopg2.errors.ForeignKeyViolation as exc:
                    pattern = (
                        &#39;Key \((\w+)\)=\(([\-\d]+)\) is not present in table &#34;(\w+)&#34;&#39;
                    )
                    fk_name, fk_pk, fk_obj = re.findall(pattern, exc.pgerror)[0]
                    delete_statement = (
                        f&#34;delete from {temp_table_name} where {fk_name} = {fk_pk}&#34;
                    )
                    curs.execute(delete_statement)
                    print(
                        f&#34;ForeignKeyViolation: tried to insert {fk_pk} into&#34;
                        f&#34;FK column {fk_name} of {self.obj}.&#34;
                        f&#34;But no row exists with {fk_obj}_id = {fk_pk} in {fk_obj}.&#34;
                    )
                    print(f&#34;Moving on without inserting any rows with this {fk_pk}&#34;)
                    fk_fail_count += 1
                    continue
            if fk_fail_count:
                print(&#34;Fail count = {}&#34;.format(fk_fail_count))

        io_obj.close()
        self._logger.debug(&#34;loading finished&#34;)

    def test(
        self, objs: D[str, T[str, L[str], L[str]]], rows: L[dict]
    ) -&gt; D[str, L[dict]]:
        &#34;&#34;&#34;
        Takes in the universe and processed namespaces and generates dict where keys are table names and values are lists of input rows

        Args:
            objs (D[str, T[str, L[str], L[str]]]): universe of model
            rows (L[dict]): example processed namespaces after PyBlocks applied

        Returns:
            D[str, L[dict]]: dictionary of mapping tables to lists of rows that would be inserted if this action were called
        &#34;&#34;&#34;
        obj_pk_name, ids, id_fks = objs[self.obj]
        pk, data = [], []

        for row in rows:
            pk_curr, data_curr = self._getvals(objs, row)
            pk.extend(pk_curr)
            data.extend(data_curr)

            for kk, vv in sorted(self.fks.items()):
                if vv.pk is not None:
                    val = vv.pk.arg_get(row)
                else:
                    val, fk_adata = vv._getvals(objs, row)

        io_obj = self._data_to_stringIO(pk, data, obj_pk_name)

        cols = (
            [obj_pk_name]
            + list(sorted(self.attrs.keys()))
            + list(sorted(self.fks.keys()))
        )
        table_rows = []
        while True:
            line = io_obj.readline()
            if not line:
                break
            table_rows.append(
                {col: val for col, val in zip(cols, line.strip(&#34;\n&#34;).split(&#34;\t&#34;))}
            )

        output = {self.obj + (&#34;_insert&#34; if self.insert else &#34;&#34;): table_rows}
        # Save the rows of recursive actions
        for kk, vv in self.fks.items():
            if vv.insert:
                if vv.obj == self.obj and vv.insert == self.insert:
                    print(&#34;!WARNING! self FKs aren&#39;t viewable in interact mode&#34;)
                else:
                    output.update(vv.test(objs, rows))
        return output

    def make_src(self) -&gt; str:
        &#34;&#34;&#34;
        Output a stringified version of action that can be run in an Airflow PythonOperator
        &#34;&#34;&#34;
        attrs = &#34;,&#34;.join(
            [&#34;%s=%s&#34; % (k, v.make_src(meta=True)) for k, v in self.attrs.items()]
        )
        template = (
            &#34;Load(obj= &#39;{{ obj }}&#39;,attrs= dict({{attrs}}),&#34;
            &#34;fks=dict({{ fks }}),pk= {{ pk }},insert={{ insert }})&#34;
        )
        fks = &#34;,&#34;.join([&#34;%s=%s&#34; % (k, v.make_src()) for k, v in self.fks.items()])
        pk = None if self.pk is None else self.pk.make_src(meta=True)
        return Template(template).render(
            obj=self.obj, attrs=attrs, fks=fks, pk=pk, insert=self.insert
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dbgen.core.action.getrandbits"><code class="name flex">
<span>def <span class="ident">getrandbits</span></span>(<span>k, /)</span>
</code></dt>
<dd>
<div class="desc"><p>getrandbits(k) -&gt; x.
Generates an int with k random bits.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dbgen.core.action.Action"><code class="flex name class">
<span>class <span class="ident">Action</span></span>
<span>(</span><span>obj: str, attrs: Dict[str, <a title="dbgen.core.funclike.ArgLike" href="funclike.html#dbgen.core.funclike.ArgLike">ArgLike</a>], fks: Dict[str, ForwardRef('<a title="dbgen.core.action.Action" href="#dbgen.core.action.Action">Action</a>')], pk: <a title="dbgen.core.funclike.Arg" href="funclike.html#dbgen.core.funclike.Arg">Arg</a> = None, insert: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>The purpose for this object is to make an easily serializable data structure
that knows how to update the database (these methods could easily be for
Model, but we don't want to send the entire model just to do this small thing)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Action(Base):
    &#34;&#34;&#34;
    The purpose for this object is to make an easily serializable data structure
    that knows how to update the database (these methods could easily be for
    Model, but we don&#39;t want to send the entire model just to do this small thing)
    &#34;&#34;&#34;

    def __init__(
        self,
        obj: str,
        attrs: D[str, ArgLike],
        fks: D[str, &#34;Action&#34;],
        pk: Arg = None,
        insert: bool = False,
    ) -&gt; None:

        self.obj = obj.lower()
        self.attrs = {k.lower(): v for k, v in attrs.items()}
        self.fks = {k.lower(): v for k, v in fks.items()}
        self.pk = pk
        self.insert = insert
        self._logger = logging.getLogger(f&#34;dbgen.run.loading.{self.obj}&#34;)
        self._logger.setLevel(logging.DEBUG)
        err = &#34;Cant insert %s if we already have PK %s&#34;
        assert (pk is None) or (not insert), err % (obj, pk)
        if isinstance(pk, Const) and pk == Const(None):
            pass
        else:
            assert isinstance(pk, (Arg, type(None))), (
                obj,
                attrs,
                fks,
                pk,
                insert,
            )
        super().__init__()

    def __str__(self) -&gt; str:
        n = len(self.attrs)
        m = len(self.fks)
        return &#34;Action&lt;%s, %d attr, %d rel&gt;&#34; % (self.obj, n, m)

    ##################
    # Public methods #
    ###################
    def tabdeps(self) -&gt; L[str]:
        &#34;&#34;&#34;All tables that are updated (they must already exist, is the logic)&#34;&#34;&#34;
        deps = []
        # Check if we are updating; if so we depend on
        if not self.insert:
            deps.append(self.obj)
        for fk in self.fks.values():
            if fk.pk is not None:
                deps.extend(fk.tabdeps())
        return deps

    def newtabs(self) -&gt; L[str]:
        &#34;&#34;&#34;All tables that could be inserted into this action&#34;&#34;&#34;
        out = [self.obj] if self.insert else []
        for a in self.fks.values():
            out.extend(a.newtabs())
        return out

    def newcols(self, universe: D[str, &#34;Obj&#34;]) -&gt; L[str]:
        &#34;&#34;&#34;All attributes that could be populated by this action&#34;&#34;&#34;
        obj = universe[self.obj]
        out = [
            self.obj + &#34;.&#34; + a
            for a in self.attrs.keys()
            if (self.insert or (a not in obj.ids()))
        ]
        for k, a in self.fks.items():
            if self.insert or (k not in obj.id_fks()):
                try:
                    out.extend([self.obj + &#34;.&#34; + k] + a.newcols(universe))
                except KeyError:
                    import pdb

                    pdb.set_trace()
        return out

    def act(
        self,
        cxn: Conn,
        objs: D[str, T[str, L[str], L[str]]],
        rows: L[dict],
        gen_name: str,
    ) -&gt; None:
        &#34;&#34;&#34;
        Top level call from a Generator to execute an action (top level is
        always insert or update, never just a select)
        &#34;&#34;&#34;
        # Initialize logger
        self._load(cxn, objs, rows, insert=self.insert)

    def rename_object(self, o: &#34;Obj&#34;, n: str) -&gt; &#34;Action&#34;:
        &#34;&#34;&#34;Replaces all references to a given object to one having a new name&#34;&#34;&#34;
        a = self.copy()
        if a.obj == o.name:
            a.obj = n
        for k, v in a.fks.items():
            a.fks[k] = v.rename_object(o, n)
        return a

    @classmethod
    def _strat(cls) -&gt; SearchStrategy:
        &#34;&#34;&#34;A hypothesis strategy for generating random examples.&#34;&#34;&#34;

        common_action_kwargs = dict(
            obj=nonempty, attrs=dictionaries(keys=nonempty, values=ArgLike._strat()),
        )
        action_ = builds(
            cls,
            fks=just(dict()),
            pk=Arg._strat(),
            insert=just(False),
            **common_action_kwargs,  # type: ignore
        )
        action0 = builds(
            cls,
            fks=dictionaries(keys=nonempty, values=action_),
            pk=Arg._strat(),
            insert=just(False),
            **common_action_kwargs,  # type: ignore
        )
        action1 = builds(
            cls,
            fks=dictionaries(keys=nonempty, values=action_),
            pk=just(None),
            insert=just(True),
            **common_action_kwargs,  # type: ignore
        )
        return one_of(action_, action0, action1)

    ###################
    # Private methods #
    ###################

    def _getvals(
        self, objs: D[str, T[str, L[str], L[str]]], row: dict,
    ) -&gt; T[L[str], L[tuple]]:
        &#34;&#34;&#34;
        Get a broadcasted list of INSERT/UPDATE values for an object, given
        Pyblock+Query output
        &#34;&#34;&#34;

        idattr, allattr = [], []
        obj_pk_name, ids, id_fks = objs[self.obj]
        for k, v in sorted(self.attrs.items(),):
            val = v.arg_get(row)
            allattr.append(val)
            if k in ids:
                idattr.append(val)

        for kk, vv in sorted(self.fks.items()):
            if vv.pk is not None:
                val = vv.pk.arg_get(row)
            else:
                val, fk_adata = vv._getvals(objs, row)

            allattr.append(val)
            if kk in id_fks:
                idattr.append(val)

        idata: L[tuple] = broadcast(idattr)
        adata: L[tuple] = broadcast(allattr)
        if self.pk is not None:
            assert not idata, &#34;Cannot provide a PK *and* identifying info&#34;
            pkdata = self.pk.arg_get(row)
            if isinstance(pkdata, int):
                idata_prime = [str(pkdata)]
            elif isinstance(pkdata, list) and isinstance(pkdata[0], int):  # HACKY
                idata_prime = pkdata
            elif isinstance(pkdata, str):
                idata_prime = [pkdata]
            elif isinstance(pkdata, list) and isinstance(pkdata[0], str):  # HACKY

                idata_prime = pkdata
            else:
                raise TypeError(
                    &#34;PK should either receive an int or a list of ints&#34;, vars(self)
                )
        else:
            idata_prime = []
            idata_dict = {}  # type: D[tuple,str]
            # Iterate through the identifying data and cache the hashed result for speed
            for idata_curr in idata:
                if idata_dict.get(idata_curr) is None:
                    idata_dict[idata_curr] = hashdata_(idata_curr)
                idata_prime.append(idata_dict[idata_curr])

        if len(idata_prime) == 1:
            idata_prime *= len(adata)  # broadcast

        lenerr = &#34;Cannot match IDs to data: %d!=%d&#34;
        assert len(idata_prime) == len(adata), lenerr % (len(idata_prime), len(adata))
        return idata_prime, adata

    def _data_to_stringIO(
        self, pk: L[str], data: L[tuple], obj_pk_name: str,
    ) -&gt; StringIO:
        &#34;&#34;&#34;
        Function takes in a path to a delimited file and returns a IO object
        where the identifying columns have been hashed into a primary key in the
        first ordinal position of the table. The hash uses the id_column_names
        so that only ID info is hashed into the hash value
        &#34;&#34;&#34;
        # All ro
        output_file_obj = StringIO()
        for i, (pk_curr, row_curr) in enumerate(set(zip(pk, data))):
            new_line = [pk_curr] + list(row_curr)  # type: ignore
            new_line = map(str, new_line)  # type: ignore
            new_line = map(  # type: ignore
                lambda x: x.replace(&#34;\t&#34;, &#34;\\t&#34;)
                .replace(&#34;\n&#34;, &#34;\\n&#34;)
                .replace(&#34;\r&#34;, &#34;\\r&#34;)
                .replace(&#34;\\&#34;, &#34;\\\\&#34;),
                new_line,
            )
            output_file_obj.write(&#34;\t&#34;.join(new_line) + &#34;\n&#34;)  # type: ignore

        output_file_obj.seek(0)

        return output_file_obj

    def _load(
        self,
        cxn: Conn,
        objs: D[str, T[str, L[str], L[str]]],
        rows: L[dict],
        insert: bool,
        test: bool = False,
    ) -&gt; L[int]:
        &#34;&#34;&#34;
        Helpful docstring
        &#34;&#34;&#34;
        self._logger.debug(&#34;recursively loading foreign keys&#34;)
        for kk, vv in self.fks.items():
            if vv.insert:
                vv._load(cxn, objs, rows, insert=True, test=test)

        self._logger.debug(&#34;Getting attributes and generating hashes&#34;)
        obj_pk_name, ids, id_fks = objs[self.obj]
        pk, data = [], []
        for row in rows:
            pk_curr, data_curr = self._getvals(objs, row)
            pk.extend(pk_curr)
            data.extend(data_curr)

        self._logger.debug(&#34;writing data to stringio object&#34;)
        io_obj = self._data_to_stringIO(pk, data, obj_pk_name)
        if not data:
            return []

        # If we are testing don&#39;t try and do sql
        if not test:
            self._load_data(cxn, obj_pk_name, io_obj, insert)

        return [int(x) for x in pk]

    def _load_data(
        self, cxn: Conn, obj_pk_name: str, io_obj: StringIO, insert: bool
    ) -&gt; None:
        &#34;&#34;&#34;
        Function that quickly loads an io_obj import the database specified
        obj_pk_name. Insert flag determines whether we update or insert.

        Args:
            cxn (Conn): connection to database to load intop
            obj_pk_name (str): name of objects primary key name
            io_obj (StringIO): StringIO to use for copy_from into database
            insert (bool): whether or not to update or insert into database

        Raises:
            ValueError: [description]
            DBgenExternalError: [description]
            ValueError: [description]
        &#34;&#34;&#34;
        # Temporary table to copy data into
        # Set name to be hash of input rows to ensure uniqueness for parallelization
        temp_table_name = self.obj + &#34;_temp_load_table_&#34; + str(getrandbits(64))

        # Need to create a temp table to copy data into
        # Add an auto_inc column so that data can be ordered by its insert location
        create_temp_table = &#34;&#34;&#34;
        DROP TABLE IF EXISTS {temp_table_name};
        CREATE TEMPORARY TABLE {temp_table_name} AS
        TABLE {obj}
        WITH NO DATA;
        ALTER TABLE {temp_table_name}
        ADD COLUMN auto_inc SERIAL NOT NULL;
        &#34;&#34;&#34;.format(
            obj=self.obj, temp_table_name=temp_table_name
        )

        cols = (
            [obj_pk_name]
            + list(sorted(self.attrs.keys()))
            + list(sorted(self.fks.keys()))
        )
        escaped_cols = [&#39;&#34;&#39; + col + &#39;&#34;&#39; for col in cols]
        if insert:
            template = jinja_env.get_template(&#34;insert.sql.jinja&#34;)
        else:
            template = jinja_env.get_template(&#34;update.sql.jinja&#34;)

        first = False
        update = True
        fk_cols = self.fks.keys()
        template_args = dict(
            obj=self.obj,
            obj_pk_name=obj_pk_name,
            temp_table_name=temp_table_name,
            all_column_names=cols,
            fk_cols=fk_cols,
            first=first,
            update=update,
        )
        load_statement = template.render(**template_args)

        with cxn.cursor() as curs:
            # Create the temp table
            curs.execute(create_temp_table)
            # Attempt the loading step 3 times
            self._logger.debug(&#34;load into temporary table&#34;)
            query_fail_count = 0
            while True:
                if query_fail_count == NUM_QUERY_TRIES:
                    raise ValueError(&#34;Query Cancel fail max reached&#34;)
                try:
                    curs.copy_from(
                        io_obj, temp_table_name, null=&#34;None&#34;, columns=escaped_cols
                    )
                    break
                except QueryCanceled:
                    print(&#34;Query cancel failed&#34;)
                    query_fail_count += 1
                    continue
                except Psycopg2Error as exc:
                    raise DBgenExternalError(exc.pgerror)

            # Try to insert everything from the temp table into the real table
            # If a foreign_key violation is hit, we delete those rows in the
            # temp table and move on
            fk_fail_count = 0
            self._logger.debug(&#34;transfer from temp table to main table&#34;)
            while True:
                if fk_fail_count == 10:
                    raise ValueError(
                        &#34;User Canceled due to large number of FK violations&#34;
                    )
                # check for ForeignKeyViolation error
                try:
                    curs.execute(load_statement)
                    break
                except psycopg2.errors.ForeignKeyViolation as exc:
                    pattern = (
                        &#39;Key \((\w+)\)=\(([\-\d]+)\) is not present in table &#34;(\w+)&#34;&#39;
                    )
                    fk_name, fk_pk, fk_obj = re.findall(pattern, exc.pgerror)[0]
                    delete_statement = (
                        f&#34;delete from {temp_table_name} where {fk_name} = {fk_pk}&#34;
                    )
                    curs.execute(delete_statement)
                    print(
                        f&#34;ForeignKeyViolation: tried to insert {fk_pk} into&#34;
                        f&#34;FK column {fk_name} of {self.obj}.&#34;
                        f&#34;But no row exists with {fk_obj}_id = {fk_pk} in {fk_obj}.&#34;
                    )
                    print(f&#34;Moving on without inserting any rows with this {fk_pk}&#34;)
                    fk_fail_count += 1
                    continue
            if fk_fail_count:
                print(&#34;Fail count = {}&#34;.format(fk_fail_count))

        io_obj.close()
        self._logger.debug(&#34;loading finished&#34;)

    def test(
        self, objs: D[str, T[str, L[str], L[str]]], rows: L[dict]
    ) -&gt; D[str, L[dict]]:
        &#34;&#34;&#34;
        Takes in the universe and processed namespaces and generates dict where keys are table names and values are lists of input rows

        Args:
            objs (D[str, T[str, L[str], L[str]]]): universe of model
            rows (L[dict]): example processed namespaces after PyBlocks applied

        Returns:
            D[str, L[dict]]: dictionary of mapping tables to lists of rows that would be inserted if this action were called
        &#34;&#34;&#34;
        obj_pk_name, ids, id_fks = objs[self.obj]
        pk, data = [], []

        for row in rows:
            pk_curr, data_curr = self._getvals(objs, row)
            pk.extend(pk_curr)
            data.extend(data_curr)

            for kk, vv in sorted(self.fks.items()):
                if vv.pk is not None:
                    val = vv.pk.arg_get(row)
                else:
                    val, fk_adata = vv._getvals(objs, row)

        io_obj = self._data_to_stringIO(pk, data, obj_pk_name)

        cols = (
            [obj_pk_name]
            + list(sorted(self.attrs.keys()))
            + list(sorted(self.fks.keys()))
        )
        table_rows = []
        while True:
            line = io_obj.readline()
            if not line:
                break
            table_rows.append(
                {col: val for col, val in zip(cols, line.strip(&#34;\n&#34;).split(&#34;\t&#34;))}
            )

        output = {self.obj + (&#34;_insert&#34; if self.insert else &#34;&#34;): table_rows}
        # Save the rows of recursive actions
        for kk, vv in self.fks.items():
            if vv.insert:
                if vv.obj == self.obj and vv.insert == self.insert:
                    print(&#34;!WARNING! self FKs aren&#39;t viewable in interact mode&#34;)
                else:
                    output.update(vv.test(objs, rows))
        return output

    def make_src(self) -&gt; str:
        &#34;&#34;&#34;
        Output a stringified version of action that can be run in an Airflow PythonOperator
        &#34;&#34;&#34;
        attrs = &#34;,&#34;.join(
            [&#34;%s=%s&#34; % (k, v.make_src(meta=True)) for k, v in self.attrs.items()]
        )
        template = (
            &#34;Load(obj= &#39;{{ obj }}&#39;,attrs= dict({{attrs}}),&#34;
            &#34;fks=dict({{ fks }}),pk= {{ pk }},insert={{ insert }})&#34;
        )
        fks = &#34;,&#34;.join([&#34;%s=%s&#34; % (k, v.make_src()) for k, v in self.fks.items()])
        pk = None if self.pk is None else self.pk.make_src(meta=True)
        return Template(template).render(
            obj=self.obj, attrs=attrs, fks=fks, pk=pk, insert=self.insert
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbgen.utils.misc.Base" href="../utils/misc.html#dbgen.utils.misc.Base">Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbgen.core.action.Action.act"><code class="name flex">
<span>def <span class="ident">act</span></span>(<span>self, cxn: Any, objs: Dict[str, Tuple[str, List[str], List[str]]], rows: List[dict], gen_name: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Top level call from a Generator to execute an action (top level is
always insert or update, never just a select)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def act(
    self,
    cxn: Conn,
    objs: D[str, T[str, L[str], L[str]]],
    rows: L[dict],
    gen_name: str,
) -&gt; None:
    &#34;&#34;&#34;
    Top level call from a Generator to execute an action (top level is
    always insert or update, never just a select)
    &#34;&#34;&#34;
    # Initialize logger
    self._load(cxn, objs, rows, insert=self.insert)</code></pre>
</details>
</dd>
<dt id="dbgen.core.action.Action.make_src"><code class="name flex">
<span>def <span class="ident">make_src</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Output a stringified version of action that can be run in an Airflow PythonOperator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_src(self) -&gt; str:
    &#34;&#34;&#34;
    Output a stringified version of action that can be run in an Airflow PythonOperator
    &#34;&#34;&#34;
    attrs = &#34;,&#34;.join(
        [&#34;%s=%s&#34; % (k, v.make_src(meta=True)) for k, v in self.attrs.items()]
    )
    template = (
        &#34;Load(obj= &#39;{{ obj }}&#39;,attrs= dict({{attrs}}),&#34;
        &#34;fks=dict({{ fks }}),pk= {{ pk }},insert={{ insert }})&#34;
    )
    fks = &#34;,&#34;.join([&#34;%s=%s&#34; % (k, v.make_src()) for k, v in self.fks.items()])
    pk = None if self.pk is None else self.pk.make_src(meta=True)
    return Template(template).render(
        obj=self.obj, attrs=attrs, fks=fks, pk=pk, insert=self.insert
    )</code></pre>
</details>
</dd>
<dt id="dbgen.core.action.Action.newcols"><code class="name flex">
<span>def <span class="ident">newcols</span></span>(<span>self, universe: Dict[str, ForwardRef('Obj')]) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>All attributes that could be populated by this action</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newcols(self, universe: D[str, &#34;Obj&#34;]) -&gt; L[str]:
    &#34;&#34;&#34;All attributes that could be populated by this action&#34;&#34;&#34;
    obj = universe[self.obj]
    out = [
        self.obj + &#34;.&#34; + a
        for a in self.attrs.keys()
        if (self.insert or (a not in obj.ids()))
    ]
    for k, a in self.fks.items():
        if self.insert or (k not in obj.id_fks()):
            try:
                out.extend([self.obj + &#34;.&#34; + k] + a.newcols(universe))
            except KeyError:
                import pdb

                pdb.set_trace()
    return out</code></pre>
</details>
</dd>
<dt id="dbgen.core.action.Action.newtabs"><code class="name flex">
<span>def <span class="ident">newtabs</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>All tables that could be inserted into this action</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newtabs(self) -&gt; L[str]:
    &#34;&#34;&#34;All tables that could be inserted into this action&#34;&#34;&#34;
    out = [self.obj] if self.insert else []
    for a in self.fks.values():
        out.extend(a.newtabs())
    return out</code></pre>
</details>
</dd>
<dt id="dbgen.core.action.Action.rename_object"><code class="name flex">
<span>def <span class="ident">rename_object</span></span>(<span>self, o: Obj, n: str) ‑> '<a title="dbgen.core.action.Action" href="#dbgen.core.action.Action">Action</a>'</span>
</code></dt>
<dd>
<div class="desc"><p>Replaces all references to a given object to one having a new name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_object(self, o: &#34;Obj&#34;, n: str) -&gt; &#34;Action&#34;:
    &#34;&#34;&#34;Replaces all references to a given object to one having a new name&#34;&#34;&#34;
    a = self.copy()
    if a.obj == o.name:
        a.obj = n
    for k, v in a.fks.items():
        a.fks[k] = v.rename_object(o, n)
    return a</code></pre>
</details>
</dd>
<dt id="dbgen.core.action.Action.tabdeps"><code class="name flex">
<span>def <span class="ident">tabdeps</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>All tables that are updated (they must already exist, is the logic)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tabdeps(self) -&gt; L[str]:
    &#34;&#34;&#34;All tables that are updated (they must already exist, is the logic)&#34;&#34;&#34;
    deps = []
    # Check if we are updating; if so we depend on
    if not self.insert:
        deps.append(self.obj)
    for fk in self.fks.values():
        if fk.pk is not None:
            deps.extend(fk.tabdeps())
    return deps</code></pre>
</details>
</dd>
<dt id="dbgen.core.action.Action.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>self, objs: Dict[str, Tuple[str, List[str], List[str]]], rows: List[dict]) ‑> Dict[str, List[dict]]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in the universe and processed namespaces and generates dict where keys are table names and values are lists of input rows</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>objs</code></strong> :&ensp;<code>D[str, T[str, L[str], L[str]]]</code></dt>
<dd>universe of model</dd>
<dt><strong><code>rows</code></strong> :&ensp;<code>L[dict]</code></dt>
<dd>example processed namespaces after PyBlocks applied</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>D[str, L[dict]]</code></dt>
<dd>dictionary of mapping tables to lists of rows that would be inserted if this action were called</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test(
    self, objs: D[str, T[str, L[str], L[str]]], rows: L[dict]
) -&gt; D[str, L[dict]]:
    &#34;&#34;&#34;
    Takes in the universe and processed namespaces and generates dict where keys are table names and values are lists of input rows

    Args:
        objs (D[str, T[str, L[str], L[str]]]): universe of model
        rows (L[dict]): example processed namespaces after PyBlocks applied

    Returns:
        D[str, L[dict]]: dictionary of mapping tables to lists of rows that would be inserted if this action were called
    &#34;&#34;&#34;
    obj_pk_name, ids, id_fks = objs[self.obj]
    pk, data = [], []

    for row in rows:
        pk_curr, data_curr = self._getvals(objs, row)
        pk.extend(pk_curr)
        data.extend(data_curr)

        for kk, vv in sorted(self.fks.items()):
            if vv.pk is not None:
                val = vv.pk.arg_get(row)
            else:
                val, fk_adata = vv._getvals(objs, row)

    io_obj = self._data_to_stringIO(pk, data, obj_pk_name)

    cols = (
        [obj_pk_name]
        + list(sorted(self.attrs.keys()))
        + list(sorted(self.fks.keys()))
    )
    table_rows = []
    while True:
        line = io_obj.readline()
        if not line:
            break
        table_rows.append(
            {col: val for col, val in zip(cols, line.strip(&#34;\n&#34;).split(&#34;\t&#34;))}
        )

    output = {self.obj + (&#34;_insert&#34; if self.insert else &#34;&#34;): table_rows}
    # Save the rows of recursive actions
    for kk, vv in self.fks.items():
        if vv.insert:
            if vv.obj == self.obj and vv.insert == self.insert:
                print(&#34;!WARNING! self FKs aren&#39;t viewable in interact mode&#34;)
            else:
                output.update(vv.test(objs, rows))
    return output</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dbgen.core" href="index.html">dbgen.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dbgen.core.action.getrandbits" href="#dbgen.core.action.getrandbits">getrandbits</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dbgen.core.action.Action" href="#dbgen.core.action.Action">Action</a></code></h4>
<ul class="two-column">
<li><code><a title="dbgen.core.action.Action.act" href="#dbgen.core.action.Action.act">act</a></code></li>
<li><code><a title="dbgen.core.action.Action.make_src" href="#dbgen.core.action.Action.make_src">make_src</a></code></li>
<li><code><a title="dbgen.core.action.Action.newcols" href="#dbgen.core.action.Action.newcols">newcols</a></code></li>
<li><code><a title="dbgen.core.action.Action.newtabs" href="#dbgen.core.action.Action.newtabs">newtabs</a></code></li>
<li><code><a title="dbgen.core.action.Action.rename_object" href="#dbgen.core.action.Action.rename_object">rename_object</a></code></li>
<li><code><a title="dbgen.core.action.Action.tabdeps" href="#dbgen.core.action.Action.tabdeps">tabdeps</a></code></li>
<li><code><a title="dbgen.core.action.Action.test" href="#dbgen.core.action.Action.test">test</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>